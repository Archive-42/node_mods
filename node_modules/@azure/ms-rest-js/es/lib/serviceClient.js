// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
import * as tslib_1 from "tslib";
import { DefaultHttpClient } from "./defaultHttpClient";
import {
  getPathStringFromParameter,
  getPathStringFromParameterPath,
} from "./operationParameter";
import { isStreamOperation } from "./operationSpec";
import { deserializationPolicy } from "./policies/deserializationPolicy";
import { exponentialRetryPolicy } from "./policies/exponentialRetryPolicy";
import { generateClientRequestIdPolicy } from "./policies/generateClientRequestIdPolicy";
import {
  userAgentPolicy,
  getDefaultUserAgentHeaderName,
  getDefaultUserAgentValue,
} from "./policies/userAgentPolicy";
import { redirectPolicy } from "./policies/redirectPolicy";
import { RequestPolicyOptions } from "./policies/requestPolicy";
import { rpRegistrationPolicy } from "./policies/rpRegistrationPolicy";
import { signingPolicy } from "./policies/signingPolicy";
import { systemErrorRetryPolicy } from "./policies/systemErrorRetryPolicy";
import { QueryCollectionFormat } from "./queryCollectionFormat";
import { MapperType } from "./serializer";
import { URLBuilder } from "./url";
import * as utils from "./util/utils";
import { stringifyXML } from "./util/xml";
import { WebResource } from "./webResource";
import { agentPolicy } from "./policies/agentPolicy";
import { proxyPolicy, getDefaultProxySettings } from "./policies/proxyPolicy";
import { throttlingRetryPolicy } from "./policies/throttlingRetryPolicy";
/**
 * @class
 * Initializes a new instance of the ServiceClient.
 */
const ServiceClient = /** @class */ (() => {
  /**
   * The ServiceClient constructor
   * @constructor
   * @param {ServiceClientCredentials} [credentials] The credentials object used for authentication.
   * @param {ServiceClientOptions} [options] The service client options that govern the behavior of the client.
   */
  class ServiceClient {
    constructor(credentials, options) {
      if (!options) {
        options = {};
      }
      if (credentials && !credentials.signRequest) {
        throw new Error(
          "credentials argument needs to implement signRequest method"
        );
      }
      this._withCredentials = options.withCredentials || false;
      this._httpClient = options.httpClient || new DefaultHttpClient();
      this._requestPolicyOptions = new RequestPolicyOptions(
        options.httpPipelineLogger
      );
      let requestPolicyFactories;
      if (Array.isArray(options.requestPolicyFactories)) {
        requestPolicyFactories = options.requestPolicyFactories;
      } else {
        requestPolicyFactories = createDefaultRequestPolicyFactories(
          credentials,
          options
        );
        if (options.requestPolicyFactories) {
          const newRequestPolicyFactories = options.requestPolicyFactories(
            requestPolicyFactories
          );
          if (newRequestPolicyFactories) {
            requestPolicyFactories = newRequestPolicyFactories;
          }
        }
      }
      this._requestPolicyFactories = requestPolicyFactories;
    }

    /**
     * Send the provided httpRequest.
     */
    sendRequest(options) {
      if (
        options === null ||
        options === undefined ||
        typeof options !== "object"
      ) {
        throw new Error(
          "options cannot be null or undefined and it must be of type object."
        );
      }
      let httpRequest;
      try {
        if (options instanceof WebResource) {
          options.validateRequestProperties();
          httpRequest = options;
        } else {
          httpRequest = new WebResource();
          httpRequest = httpRequest.prepare(options);
        }
      } catch (error) {
        return Promise.reject(error);
      }
      let httpPipeline = this._httpClient;
      if (
        this._requestPolicyFactories &&
        this._requestPolicyFactories.length > 0
      ) {
        for (let i = this._requestPolicyFactories.length - 1; i >= 0; --i) {
          httpPipeline = this._requestPolicyFactories[i].create(
            httpPipeline,
            this._requestPolicyOptions
          );
        }
      }
      return httpPipeline.sendRequest(httpRequest);
    }

    /**
     * Send an HTTP request that is populated using the provided OperationSpec.
     * @param {OperationArguments} operationArguments The arguments that the HTTP request's templated values will be populated from.
     * @param {OperationSpec} operationSpec The OperationSpec to use to populate the httpRequest.
     * @param {ServiceCallback} callback The callback to call when the response is received.
     */
    sendOperationRequest(operationArguments, operationSpec, callback) {
      if (typeof operationArguments.options === "function") {
        callback = operationArguments.options;
        operationArguments.options = undefined;
      }
      const httpRequest = new WebResource();
      let result;
      try {
        const baseUri = operationSpec.baseUrl || this.baseUri;
        if (!baseUri) {
          throw new Error(
            "If operationSpec.baseUrl is not specified, then the ServiceClient must have a baseUri string property that contains the base URL to use."
          );
        }
        httpRequest.method = operationSpec.httpMethod;
        httpRequest.operationSpec = operationSpec;
        const requestUrl = URLBuilder.parse(baseUri);
        if (operationSpec.path) {
          requestUrl.appendPath(operationSpec.path);
        }
        if (
          operationSpec.urlParameters &&
          operationSpec.urlParameters.length > 0
        ) {
          for (
            let _i = 0, _a = operationSpec.urlParameters;
            _i < _a.length;
            _i++
          ) {
            const urlParameter = _a[_i];
            let urlParameterValue = getOperationArgumentValueFromParameter(
              this,
              operationArguments,
              urlParameter,
              operationSpec.serializer
            );
            urlParameterValue = operationSpec.serializer.serialize(
              urlParameter.mapper,
              urlParameterValue,
              getPathStringFromParameter(urlParameter)
            );
            if (!urlParameter.skipEncoding) {
              urlParameterValue = encodeURIComponent(urlParameterValue);
            }
            requestUrl.replaceAll(
              `{${urlParameter.mapper.serializedName ||
    getPathStringFromParameter(urlParameter)}}`,
              urlParameterValue
            );
          }
        }
        if (
          operationSpec.queryParameters &&
          operationSpec.queryParameters.length > 0
        ) {
          for (
            let _b = 0, _c = operationSpec.queryParameters;
            _b < _c.length;
            _b++
          ) {
            const queryParameter = _c[_b];
            let queryParameterValue = getOperationArgumentValueFromParameter(
              this,
              operationArguments,
              queryParameter,
              operationSpec.serializer
            );
            if (queryParameterValue != undefined) {
              queryParameterValue = operationSpec.serializer.serialize(
                queryParameter.mapper,
                queryParameterValue,
                getPathStringFromParameter(queryParameter)
              );
              if (queryParameter.collectionFormat != undefined) {
                if (
                  queryParameter.collectionFormat === QueryCollectionFormat.Multi
                ) {
                  if (queryParameterValue.length === 0) {
                    queryParameterValue = "";
                  } else {
                    for (var index in queryParameterValue) {
                      const item = queryParameterValue[index];
                      queryParameterValue[index] =
                        item == undefined ? "" : item.toString();
                    }
                  }
                } else {
                  queryParameterValue = queryParameterValue.join(
                    queryParameter.collectionFormat
                  );
                }
              }
              if (!queryParameter.skipEncoding) {
                if (Array.isArray(queryParameterValue)) {
                  for (var index in queryParameterValue) {
                    queryParameterValue[index] = encodeURIComponent(
                      queryParameterValue[index]
                    );
                  }
                } else {
                  queryParameterValue = encodeURIComponent(queryParameterValue);
                }
              }
              requestUrl.setQueryParameter(
                queryParameter.mapper.serializedName ||
                  getPathStringFromParameter(queryParameter),
                queryParameterValue
              );
            }
          }
        }
        httpRequest.url = requestUrl.toString();
        const contentType = operationSpec.contentType || this.requestContentType;
        if (contentType) {
          httpRequest.headers.set("Content-Type", contentType);
        }
        if (operationSpec.headerParameters) {
          for (
            let _d = 0, _e = operationSpec.headerParameters;
            _d < _e.length;
            _d++
          ) {
            const headerParameter = _e[_d];
            let headerValue = getOperationArgumentValueFromParameter(
              this,
              operationArguments,
              headerParameter,
              operationSpec.serializer
            );
            if (headerValue != undefined) {
              headerValue = operationSpec.serializer.serialize(
                headerParameter.mapper,
                headerValue,
                getPathStringFromParameter(headerParameter)
              );
              const headerCollectionPrefix =
                headerParameter.mapper.headerCollectionPrefix;
              if (headerCollectionPrefix) {
                for (
                  let _f = 0, _g = Object.keys(headerValue);
                  _f < _g.length;
                  _f++
                ) {
                  const key = _g[_f];
                  httpRequest.headers.set(
                    headerCollectionPrefix + key,
                    headerValue[key]
                  );
                }
              } else {
                httpRequest.headers.set(
                  headerParameter.mapper.serializedName ||
                    getPathStringFromParameter(headerParameter),
                  headerValue
                );
              }
            }
          }
        }
        const options = operationArguments.options;
        if (options) {
          if (options.customHeaders) {
            for (const customHeaderName in options.customHeaders) {
              httpRequest.headers.set(
                customHeaderName,
                options.customHeaders[customHeaderName]
              );
            }
          }
          if (options.abortSignal) {
            httpRequest.abortSignal = options.abortSignal;
          }
          if (options.timeout) {
            httpRequest.timeout = options.timeout;
          }
          if (options.onUploadProgress) {
            httpRequest.onUploadProgress = options.onUploadProgress;
          }
          if (options.onDownloadProgress) {
            httpRequest.onDownloadProgress = options.onDownloadProgress;
          }
        }
        httpRequest.withCredentials = this._withCredentials;
        serializeRequestBody(
          this,
          httpRequest,
          operationArguments,
          operationSpec
        );
        if (httpRequest.streamResponseBody == undefined) {
          httpRequest.streamResponseBody = isStreamOperation(operationSpec);
        }
        result = this.sendRequest(httpRequest).then(res => {
          return flattenResponse(res, operationSpec.responses[res.status]);
        });
      } catch (error) {
        result = Promise.reject(error);
      }
      const cb = callback;
      if (cb) {
        result
          // tslint:disable-next-line:no-null-keyword
          .then(({_response}) => {
            return cb(
              null,
              _response.parsedBody,
              _response.request,
              _response
            );
          })
          .catch(err => {
            return cb(err);
          });
      }
      return result;
    }
  }

  return ServiceClient;
})();
export { ServiceClient };
export function serializeRequestBody(
  serviceClient,
  httpRequest,
  operationArguments,
  {requestBody, serializer, isXML, formDataParameters}
) {
  if (requestBody && requestBody.mapper) {
    httpRequest.body = getOperationArgumentValueFromParameter(
      serviceClient,
      operationArguments,
      requestBody,
      serializer
    );
    const bodyMapper = requestBody.mapper;
    const required = bodyMapper.required;
    const xmlName = bodyMapper.xmlName;
    const xmlElementName = bodyMapper.xmlElementName;
    const serializedName = bodyMapper.serializedName;
    const typeName = bodyMapper.type.name;
    try {
      if (httpRequest.body != undefined || required) {
        const requestBodyParameterPathString = getPathStringFromParameter(
          requestBody
        );
        httpRequest.body = serializer.serialize(
          bodyMapper,
          httpRequest.body,
          requestBodyParameterPathString
        );
        const isStream = typeName === MapperType.Stream;
        if (isXML) {
          if (typeName === MapperType.Sequence) {
            httpRequest.body = stringifyXML(
              utils.prepareXMLRootList(
                httpRequest.body,
                xmlElementName || xmlName || serializedName
              ),
              { rootName: xmlName || serializedName }
            );
          } else if (!isStream) {
            httpRequest.body = stringifyXML(httpRequest.body, {
              rootName: xmlName || serializedName,
            });
          }
        } else if (!isStream) {
          httpRequest.body = JSON.stringify(httpRequest.body);
        }
      }
    } catch (error) {
      throw new Error(
        `Error "${error.message}" occurred in serializing the payload - ${JSON.stringify(serializedName, undefined, "  ")}.`
      );
    }
  } else if (
    formDataParameters &&
    formDataParameters.length > 0
  ) {
    httpRequest.formData = {};
    for (
      let _i = 0, _a = formDataParameters;
      _i < _a.length;
      _i++
    ) {
      const formDataParameter = _a[_i];
      const formDataParameterValue = getOperationArgumentValueFromParameter(
        serviceClient,
        operationArguments,
        formDataParameter,
        serializer
      );
      if (formDataParameterValue != undefined) {
        const formDataParameterPropertyName =
          formDataParameter.mapper.serializedName ||
          getPathStringFromParameter(formDataParameter);
        httpRequest.formData[formDataParameterPropertyName] =
          serializer.serialize(
            formDataParameter.mapper,
            formDataParameterValue,
            getPathStringFromParameter(formDataParameter)
          );
      }
    }
  }
}
function isRequestPolicyFactory({create}) {
  return typeof create === "function";
}
function getValueOrFunctionResult(value, defaultValueCreator) {
  let result;
  if (typeof value === "string") {
    result = value;
  } else {
    result = defaultValueCreator();
    if (typeof value === "function") {
      result = value(result);
    }
  }
  return result;
}
function createDefaultRequestPolicyFactories(credentials, options) {
  const factories = [];
  if (options.generateClientRequestIdHeader) {
    factories.push(
      generateClientRequestIdPolicy(options.clientRequestIdHeaderName)
    );
  }
  if (credentials) {
    if (isRequestPolicyFactory(credentials)) {
      factories.push(credentials);
    } else {
      factories.push(signingPolicy(credentials));
    }
  }
  const userAgentHeaderName = getValueOrFunctionResult(
    options.userAgentHeaderName,
    getDefaultUserAgentHeaderName
  );
  const userAgentHeaderValue = getValueOrFunctionResult(
    options.userAgent,
    getDefaultUserAgentValue
  );
  if (userAgentHeaderName && userAgentHeaderValue) {
    factories.push(
      userAgentPolicy({ key: userAgentHeaderName, value: userAgentHeaderValue })
    );
  }
  factories.push(redirectPolicy());
  factories.push(rpRegistrationPolicy(options.rpRegistrationRetryTimeout));
  if (!options.noRetryPolicy) {
    factories.push(exponentialRetryPolicy());
    factories.push(systemErrorRetryPolicy());
    factories.push(throttlingRetryPolicy());
  }
  factories.push(deserializationPolicy(options.deserializationContentTypes));
  const proxySettings = options.proxySettings || getDefaultProxySettings();
  if (proxySettings) {
    factories.push(proxyPolicy(proxySettings));
  }
  if (options.agentSettings) {
    factories.push(agentPolicy(options.agentSettings));
  }
  return factories;
}
/**
 * Get the property parent for the property at the provided path when starting with the provided
 * parent object.
 */
export function getPropertyParent(parent, propertyPath) {
  if (parent && propertyPath) {
    const propertyPathLength = propertyPath.length;
    for (let i = 0; i < propertyPathLength - 1; ++i) {
      const propertyName = propertyPath[i];
      if (!parent[propertyName]) {
        parent[propertyName] = {};
      }
      parent = parent[propertyName];
    }
  }
  return parent;
}
function getOperationArgumentValueFromParameter(serviceClient, operationArguments, {parameterPath, mapper}, serializer) {
  return getOperationArgumentValueFromParameterPath(
    serviceClient,
    operationArguments,
    parameterPath,
    mapper,
    serializer
  );
}
export function getOperationArgumentValueFromParameterPath(
  serviceClient,
  operationArguments,
  parameterPath,
  parameterMapper,
  serializer
) {
  let value;
  if (typeof parameterPath === "string") {
    parameterPath = [parameterPath];
  }
  if (Array.isArray(parameterPath)) {
    if (parameterPath.length > 0) {
      if (parameterMapper.isConstant) {
        value = parameterMapper.defaultValue;
      } else {
        let propertySearchResult = getPropertyFromParameterPath(
          operationArguments,
          parameterPath
        );
        if (!propertySearchResult.propertyFound) {
          propertySearchResult = getPropertyFromParameterPath(
            serviceClient,
            parameterPath
          );
        }
        let useDefaultValue = false;
        if (!propertySearchResult.propertyFound) {
          useDefaultValue =
            parameterMapper.required ||
            (parameterPath[0] === "options" && parameterPath.length === 2);
        }
        value = useDefaultValue
          ? parameterMapper.defaultValue
          : propertySearchResult.propertyValue;
      }
      // Serialize just for validation purposes.
      const parameterPathString = getPathStringFromParameterPath(
        parameterPath,
        parameterMapper
      );
      serializer.serialize(parameterMapper, value, parameterPathString);
    }
  } else {
    if (parameterMapper.required) {
      value = {};
    }
    for (const propertyName in parameterPath) {
      const propertyMapper = parameterMapper.type.modelProperties[propertyName];
      const propertyPath = parameterPath[propertyName];
      const propertyValue = getOperationArgumentValueFromParameterPath(
        serviceClient,
        operationArguments,
        propertyPath,
        propertyMapper,
        serializer
      );
      // Serialize just for validation purposes.
      const propertyPathString = getPathStringFromParameterPath(
        propertyPath,
        propertyMapper
      );
      serializer.serialize(propertyMapper, propertyValue, propertyPathString);
      if (propertyValue !== undefined) {
        if (!value) {
          value = {};
        }
        value[propertyName] = propertyValue;
      }
    }
  }
  return value;
}
function getPropertyFromParameterPath(parent, parameterPath) {
  const result = { propertyFound: false };
  let i = 0;
  for (; i < parameterPath.length; ++i) {
    const parameterPathPart = parameterPath[i];
    // Make sure to check inherited properties too, so don't use hasOwnProperty().
    if (parent != undefined && parameterPathPart in parent) {
      parent = parent[parameterPathPart];
    } else {
      break;
    }
  }
  if (i === parameterPath.length) {
    result.propertyValue = parent;
    result.propertyFound = true;
  }
  return result;
}
export function flattenResponse(_response, responseSpec) {
  const parsedHeaders = _response.parsedHeaders;
  const bodyMapper = responseSpec && responseSpec.bodyMapper;
  const addOperationResponse = obj => {
    return Object.defineProperty(obj, "_response", {
      value: _response,
    });
  };
  if (bodyMapper) {
    const typeName = bodyMapper.type.name;
    if (typeName === "Stream") {
      return addOperationResponse(
        tslib_1.__assign({}, parsedHeaders, {
          blobBody: _response.blobBody,
          readableStreamBody: _response.readableStreamBody,
        })
      );
    }
    const modelProperties_1 =
      (typeName === "Composite" && bodyMapper.type.modelProperties) || {};
    const isPageableResponse = Object.keys(modelProperties_1).some(k => {
      return modelProperties_1[k].serializedName === "";
    });
    if (typeName === "Sequence" || isPageableResponse) {
      // We're expecting a sequence(array) make sure that the response body is in the
      // correct format, if not make it an empty array []
      const parsedBody = Array.isArray(_response.parsedBody)
        ? _response.parsedBody
        : [];
      const arrayResponse = parsedBody.slice();
      for (
        let _i = 0, _a = Object.keys(modelProperties_1);
        _i < _a.length;
        _i++
      ) {
        var key = _a[_i];
        if (modelProperties_1[key].serializedName) {
          arrayResponse[key] = _response.parsedBody[key];
        }
      }
      if (parsedHeaders) {
        for (
          let _b = 0, _c = Object.keys(parsedHeaders);
          _b < _c.length;
          _b++
        ) {
          var key = _c[_b];
          arrayResponse[key] = parsedHeaders[key];
        }
      }
      addOperationResponse(arrayResponse);
      return arrayResponse;
    }
    if (typeName === "Composite" || typeName === "Dictionary") {
      return addOperationResponse(
        tslib_1.__assign({}, parsedHeaders, _response.parsedBody)
      );
    }
  }
  if (bodyMapper || _response.request.method === "HEAD") {
    // primitive body types and HEAD booleans
    return addOperationResponse(
      tslib_1.__assign({}, parsedHeaders, { body: _response.parsedBody })
    );
  }
  return addOperationResponse(
    tslib_1.__assign({}, parsedHeaders, _response.parsedBody)
  );
}
//# sourceMappingURL=serviceClient.js.map
