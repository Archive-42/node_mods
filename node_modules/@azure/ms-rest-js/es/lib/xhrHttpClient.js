// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
import { HttpHeaders } from "./httpHeaders";
import { RestError } from "./restError";
/**
 * A HttpClient implementation that uses XMLHttpRequest to send HTTP requests.
 */
const XhrHttpClient = /** @class */ (() => {
  class XhrHttpClient {
    sendRequest(request) {
      const xhr = new XMLHttpRequest();
      if (request.agentSettings) {
        throw new Error(
          "HTTP agent settings not supported in browser environment"
        );
      }
      if (request.proxySettings) {
        throw new Error("HTTP proxy is not supported in browser environment");
      }
      const abortSignal = request.abortSignal;
      if (abortSignal) {
        const listener_1 = () => {
          xhr.abort();
        };
        abortSignal.addEventListener("abort", listener_1);
        xhr.addEventListener("readystatechange", () => {
          if (xhr.readyState === XMLHttpRequest.DONE) {
            abortSignal.removeEventListener("abort", listener_1);
          }
        });
      }
      addProgressListener(xhr.upload, request.onUploadProgress);
      addProgressListener(xhr, request.onDownloadProgress);
      if (request.formData) {
        const formData = request.formData;
        const requestForm_1 = new FormData();
        const appendFormValue = (key, value) => {
          if (
            value &&
            value.hasOwnProperty("value") &&
            value.hasOwnProperty("options")
          ) {
            requestForm_1.append(key, value.value, value.options);
          } else {
            requestForm_1.append(key, value);
          }
        };
        for (let _i = 0, _a = Object.keys(formData); _i < _a.length; _i++) {
          const formKey = _a[_i];
          const formValue = formData[formKey];
          if (Array.isArray(formValue)) {
            for (let j = 0; j < formValue.length; j++) {
              appendFormValue(formKey, formValue[j]);
            }
          } else {
            appendFormValue(formKey, formValue);
          }
        }
        request.body = requestForm_1;
        request.formData = undefined;
        const contentType = request.headers.get("Content-Type");
        if (contentType && contentType.includes("multipart/form-data")) {
          // browser will automatically apply a suitable content-type header
          request.headers.remove("Content-Type");
        }
      }
      xhr.open(request.method, request.url);
      xhr.timeout = request.timeout;
      xhr.withCredentials = request.withCredentials;
      for (
        let _b = 0, _c = request.headers.headersArray();
        _b < _c.length;
        _b++
      ) {
        const header = _c[_b];
        xhr.setRequestHeader(header.name, header.value);
      }
      xhr.responseType = request.streamResponseBody ? "blob" : "text";
      // tslint:disable-next-line:no-null-keyword
      xhr.send(request.body === undefined ? null : request.body);
      if (request.streamResponseBody) {
        return new Promise((resolve, reject) => {
          xhr.addEventListener("readystatechange", () => {
            // Resolve as soon as headers are loaded
            if (xhr.readyState === XMLHttpRequest.HEADERS_RECEIVED) {
              const blobBody = new Promise((resolve, reject) => {
                xhr.addEventListener("load", () => {
                  resolve(xhr.response);
                });
                rejectOnTerminalEvent(request, xhr, reject);
              });
              resolve({
                request: request,
                status: xhr.status,
                headers: parseHeaders(xhr),
                blobBody: blobBody,
              });
            }
          });
          rejectOnTerminalEvent(request, xhr, reject);
        });
      } else {
        return new Promise((resolve, reject) => {
          xhr.addEventListener("load", () => {
            return resolve({
              request: request,
              status: xhr.status,
              headers: parseHeaders(xhr),
              bodyAsText: xhr.responseText,
            });
          });
          rejectOnTerminalEvent(request, xhr, reject);
        });
      }
    }
  }

  return XhrHttpClient;
})();
export { XhrHttpClient };
function addProgressListener(xhr, listener) {
  if (listener) {
    xhr.addEventListener("progress", ({loaded}) => {
      return listener({
        loadedBytes: loaded,
      });
    });
  }
}
// exported locally for testing
export function parseHeaders(xhr) {
  const responseHeaders = new HttpHeaders();
  const headerLines = xhr
    .getAllResponseHeaders()
    .trim()
    .split(/[\r\n]+/);
  for (
    let _i = 0, headerLines_1 = headerLines;
    _i < headerLines_1.length;
    _i++
  ) {
    const line = headerLines_1[_i];
    const index = line.indexOf(":");
    const headerName = line.slice(0, index);
    const headerValue = line.slice(index + 2);
    responseHeaders.set(headerName, headerValue);
  }
  return responseHeaders;
}
function rejectOnTerminalEvent(request, xhr, reject) {
  xhr.addEventListener("error", () => {
    return reject(
      new RestError(
        `Failed to send request to ${request.url}`,
        RestError.REQUEST_SEND_ERROR,
        undefined,
        request
      )
    );
  });
  xhr.addEventListener("abort", () => {
    return reject(
      new RestError(
        "The request was aborted",
        RestError.REQUEST_ABORTED_ERROR,
        undefined,
        request
      )
    );
  });
  xhr.addEventListener("timeout", () => {
    return reject(
      new RestError(
        `timeout of ${xhr.timeout}ms exceeded`,
        RestError.REQUEST_SEND_ERROR,
        undefined,
        request
      )
    );
  });
}
//# sourceMappingURL=xhrHttpClient.js.map
