/** @license ms-rest-js
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt and ThirdPartyNotices.txt in the project root for license information.
 */
!((e, t) => {
  "object" == typeof exports && "undefined" != typeof module
    ? t(exports)
    : "function" == typeof define && define.amd
    ? define(["exports"], t)
    : t((e.msRest = {}));
})(this, N => {
  "use strict";
  function r(e) {
    return e.toLowerCase();
  }
  const d =
    ((e.prototype.set = function (e, t) {
      this._headersMap[r(e)] = { name: e, value: t.toString() };
    }),
    (e.prototype.get = function (e) {
      const t = this._headersMap[r(e)];
      return t ? t.value : void 0;
    }),
    (e.prototype.contains = function (e) {
      return !!this._headersMap[r(e)];
    }),
    (e.prototype.remove = function (e) {
      const t = this.contains(e);
      return delete this._headersMap[r(e)], t;
    }),
    (e.prototype.rawHeaders = function () {
      const e = {};
      for (const t in this._headersMap) {
        const r = this._headersMap[t];
        e[r.name.toLowerCase()] = r.value;
      }
      return e;
    }),
    (e.prototype.headersArray = function () {
      const e = [];
      for (const t in this._headersMap) e.push(this._headersMap[t]);
      return e;
    }),
    (e.prototype.headerNames = function () {
      for (var e = [], t = this.headersArray(), r = 0; r < t.length; ++r)
        e.push(t[r].name);
      return e;
    }),
    (e.prototype.headerValues = function () {
      for (var e = [], t = this.headersArray(), r = 0; r < t.length; ++r)
        e.push(t[r].value);
      return e;
    }),
    (e.prototype.toJson = function () {
      return this.rawHeaders();
    }),
    (e.prototype.toString = function () {
      return JSON.stringify(this.toJson());
    }),
    (e.prototype.clone = function () {
      return new e(this.rawHeaders());
    }),
    e);
  function e(e) {
    if (((this._headersMap = {}), e)) for (const t in e) this.set(t, e[t]);
  }
  function s(e) {
    for (var t = "", r = 0; r < e.length; r++) t += String.fromCharCode(e[r]);
    return btoa(t);
  }
  function a(e) {
    for (
      var t = atob(e), r = new Uint8Array(t.length), n = 0;
      n < t.length;
      n++
    )
      r[n] = t.charCodeAt(n);
    return r;
  }
  for (
    var t,
      u =
        ((e => {
          const t =
            ("undefined" != typeof crypto &&
              crypto.getRandomValues &&
              crypto.getRandomValues.bind(crypto)) ||
            ("undefined" != typeof msCrypto &&
              "function" == typeof window.msCrypto.getRandomValues &&
              msCrypto.getRandomValues.bind(msCrypto));
          if (t) {
            const r = new Uint8Array(16);
            e.exports = () => {
              return t(r), r;
            };
          } else {
            const n = new Array(16);
            e.exports = () => {
              for (let e, t = 0; t < 16; t++)
                0 == (3 & t) && (e = 4294967296 * Math.random()),
                  (n[t] = (e >>> ((3 & t) << 3)) & 255);
              return n;
            };
          }
        })(t = { exports: {} }, t.exports), t.exports),
      n = [],
      o = 0;
    o < 256;
    ++o
  )
    n[o] = (o + 256).toString(16).substr(1);
  const l = (e, t) => {
    let r = t || 0;
    return [
      n[e[r++]],
      n[e[r++]],
      n[e[r++]],
      n[e[r++]],
      "-",
      n[e[r++]],
      n[e[r++]],
      "-",
      n[e[r++]],
      n[e[r++]],
      "-",
      n[e[r++]],
      n[e[r++]],
      "-",
      n[e[r++]],
      n[e[r++]],
      n[e[r++]],
      n[e[r++]],
      n[e[r++]],
      n[e[r++]],
    ].join("");
  };

  const i = (e, t, r) => {
            const n = (t && r) || 0;
            "string" == typeof e &&
              ((t = "binary" === e ? new Array(16) : null), (e = null));
            const o = (e = e || {}).random || (e.rng || u)();
            if (((o[6] = (15 & o[6]) | 64), (o[8] = (63 & o[8]) | 128), t))
              for (let i = 0; i < 16; ++i) t[n + i] = o[i];
            return t || l(o);
          };

  const c = {
    msRestVersion: "1.9.1",
    HTTP: "http:",
    HTTPS: "https:",
    HTTP_PROXY: "HTTP_PROXY",
    HTTPS_PROXY: "HTTPS_PROXY",
    HttpConstants: {
      HttpVerbs: {
        PUT: "PUT",
        GET: "GET",
        DELETE: "DELETE",
        POST: "POST",
        MERGE: "MERGE",
        HEAD: "HEAD",
        PATCH: "PATCH",
      },
      StatusCodes: { TooManyRequests: 429 },
    },
    HeaderConstants: {
      AUTHORIZATION: "authorization",
      AUTHORIZATION_SCHEME: "Bearer",
      RETRY_AFTER: "Retry-After",
      USER_AGENT: "User-Agent",
    },
  };

  const f =
    "undefined" != typeof process &&
    !!process.version &&
    !!process.versions &&
    !!process.versions.node;

  function v({bodyAsText, headers, status}) {
    const t = {};
    return (t.body = bodyAsText), (t.headers = headers), (t.status = status), t
  ;
  }
  function g(e) {
    const t = e.clone();
    return t.headers && t.headers.remove("authorization"), t;
  }
  function p(e) {
    return new RegExp(
      "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$",
      "ig"
    ).test(e);
  }
  function y() {
    return i();
  }
  function h(t, r) {
    return new Promise(e => {
      return setTimeout(() => {
        return e(r);
      }, t);
    });
  }
  const m =
    /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;
  function b(e) {
    return m.test(e);
  }
  function w(e, t, r) {
    return e && t ? e.split(t).join(r || "") : e;
  }
  const E =
    ((R.prototype.validateConstraints = ({constraints}, r, n) => {
      function t(e, t) {
        throw new Error(
          `"${n}" with value "${r}" should satisfy the constraint "${e}": ${t}.`
        );
      }
      if (constraints && null != r) {
        const o = constraints;
        const i = o.ExclusiveMaximum;
        const a = o.ExclusiveMinimum;
        const s = o.InclusiveMaximum;
        const u = o.InclusiveMinimum;
        const l = o.MaxItems;
        const c = o.MaxLength;
        const f = o.MinItems;
        const p = o.MinLength;
        const h = o.MultipleOf;
        const d = o.Pattern;
        const y = o.UniqueItems;
        null != i && i <= r && t("ExclusiveMaximum", i),
          null != a && r <= a && t("ExclusiveMinimum", a),
          null != s && s < r && t("InclusiveMaximum", s),
          null != u && r < u && t("InclusiveMinimum", u),
          null != l && r.length > l && t("MaxItems", l),
          null != c && r.length > c && t("MaxLength", c),
          null != f && r.length < f && t("MinItems", f),
          null != p && r.length < p && t("MinLength", p),
          null != h && r % h != 0 && t("MultipleOf", h),
          d && null === r.match(d) && t("Pattern", d),
          y &&
            r.some((e, t, r) => {
              return r.indexOf(e) !== t;
            }) &&
            t("UniqueItems", y);
      }
    }),
    (R.prototype.serialize = function (e, t, r) {
    let n = {};
    const o = e.type.name;
    (r = r || e.serializedName),
      null !== o.match(/^Sequence$/gi) && (n = []),
      null != t ||
        (null == e.defaultValue && !e.isConstant) ||
        (t = e.defaultValue);
    const i = e.required;
    const a = e.nullable;
    if (i && a && void 0 === t) throw new Error(`${r} cannot be undefined.`);
    if (i && !a && null == t)
      throw new Error(`${r} cannot be null or undefined.`);
    if (!i && !1 === a && null === t) throw new Error(`${r} cannot be null.`);
    return null == t
      ? (n = t)
      : (this.validateConstraints(e, t, r),
        null !== o.match(/^any$/gi)
          ? (n = t)
          : null !==
            o.match(/^(Number|String|Boolean|Object|Stream|Uuid)$/gi)
          ? (n = ((e, t, r) => {
              if (null != r)
                if (null !== e.match(/^Number$/gi)) {
                  if ("number" != typeof r)
                    throw new Error(
                      `${t} with value ${r} must be of type number.`
                    );
                } else if (null !== e.match(/^String$/gi)) {
                  if ("string" != typeof r.valueOf())
                    throw new Error(
                      `${t} with value "${r}" must be of type string.`
                    );
                } else if (null !== e.match(/^Uuid$/gi)) {
                  if ("string" != typeof r.valueOf() || !p(r))
                    throw new Error(
                      `${t} with value "${r}" must be of type string and a valid uuid.`
                    );
                } else if (null !== e.match(/^Boolean$/gi)) {
                  if ("boolean" != typeof r)
                    throw new Error(
                      `${t} with value ${r} must be of type boolean.`
                    );
                } else if (null !== e.match(/^Stream$/gi)) {
                  const n = typeof r;
                  if (
                    !(
                      "string" == n ||
                      "function" == n ||
                      r instanceof ArrayBuffer ||
                      ArrayBuffer.isView(r) ||
                      ("function" == typeof Blob && r instanceof Blob)
                    )
                  )
                    throw new Error(
                      `${t} must be a string, Blob, ArrayBuffer, ArrayBufferView, or a function returning NodeJS.ReadableStream.`
                    );
                }
              return r;
            })(o, r, t))
          : null !== o.match(/^Enum$/gi)
          ? (n = ((e, t, r) => {
              if (!t)
                throw new Error(
                  `Please provide a set of allowedValues to validate ${e} as an Enum Type.`
                );
              if (
                t.some(e => {
                  return "string" == typeof e.valueOf()
                    ? e.toLowerCase() === r.toLowerCase()
                    : e === r;
                })
              )
                return r;
              throw new Error(
                `${r} is not a valid value for ${e}. The valid values are: ${JSON.stringify(t)}.`
              );
            })(r, e.type.allowedValues, t))
          : null !==
            o.match(/^(Date|DateTime|TimeSpan|DateTimeRfc1123|UnixTime)$/gi)
          ? (n = ((e, t, r) => {
              if (null != t)
                if (null !== e.match(/^Date$/gi)) {
                  if (
                    !(
                      t instanceof Date ||
                      ("string" == typeof t.valueOf() &&
                        !isNaN(Date.parse(t)))
                    )
                  )
                    throw new Error(
                      `${r} must be an instanceof Date or a string in ISO8601 format.`
                    );
                  t =
                    t instanceof Date
                      ? t.toISOString().substring(0, 10)
                      : new Date(t).toISOString().substring(0, 10);
                } else if (null !== e.match(/^DateTime$/gi)) {
                  if (
                    !(
                      t instanceof Date ||
                      ("string" == typeof t.valueOf() &&
                        !isNaN(Date.parse(t)))
                    )
                  )
                    throw new Error(
                      `${r} must be an instanceof Date or a string in ISO8601 format.`
                    );
                  t =
                    t instanceof Date
                      ? t.toISOString()
                      : new Date(t).toISOString();
                } else if (null !== e.match(/^DateTimeRfc1123$/gi)) {
                  if (
                    !(
                      t instanceof Date ||
                      ("string" == typeof t.valueOf() &&
                        !isNaN(Date.parse(t)))
                    )
                  )
                    throw new Error(
                      `${r} must be an instanceof Date or a string in RFC-1123 format.`
                    );
                  t =
                    t instanceof Date
                      ? t.toUTCString()
                      : new Date(t).toUTCString();
                } else if (null !== e.match(/^UnixTime$/gi)) {
                  if (
                    !(
                      t instanceof Date ||
                      ("string" == typeof t.valueOf() &&
                        !isNaN(Date.parse(t)))
                    )
                  )
                    throw new Error(
                      `${r} must be an instanceof Date or a string in RFC-1123/ISO8601 format for it to be serialized in UnixTime/Epoch format.`
                    );
                  t = (e => {
                    if (e)
                      return (
                        "string" == typeof e.valueOf() && (e = new Date(e)),
                        Math.floor(e.getTime() / 1e3)
                      );
                  })(t);
                } else if (null !== e.match(/^TimeSpan$/gi)) {
                  if (!b(t))
                    throw new Error(
                      `${r} must be a string in ISO 8601 format. Instead was "${t}".`
                    );
                  t = t;
                }
              return t;
            })(o, t, r))
          : null !== o.match(/^ByteArray$/gi)
          ? (n = ((e, t) => {
              if (null != t) {
                if (!(t instanceof Uint8Array))
                  throw new Error(`${e} must be of type Uint8Array.`);
                t = s(t);
              }
              return t;
            })(r, t))
          : null !== o.match(/^Base64Url$/gi)
          ? (n = ((e, t) => {
              if (null != t) {
                if (!(t instanceof Uint8Array))
                  throw new Error(`${e} must be of type Uint8Array.`);
                t = (e => {
                  if (e) {
                    if (e instanceof Uint8Array)
                      return ((e, t) => {
                        for (
                          var r = e.length;
                          0 <= r - 1 && e[r - 1] === t;

                        )
                          --r;
                        return e.substr(0, r);
                      })(s(e), "=").replace(/\+/g, "-")
                        .replace(/\//g, "_");
                    throw new Error(
                      "Please provide an input of type Uint8Array for converting to Base64Url."
                    );
                  }
                })(t);
              }
              return t;
            })(r, t))
          : null !== o.match(/^Sequence$/gi)
          ? (n = ((e, {type}, r, n) => {
              if (!Array.isArray(r))
                throw new Error(`${n} must be of type Array.`);
              const o = type.element;
              if (!o || "object" != typeof o)
                throw new Error(
                  `element" metadata for an Array must be defined in the mapper and it must of type "object" in ${n}.`
                );
              for (var i = [], a = 0; a < r.length; a++)
                i[a] = e.serialize(o, r[a], n);
              return i;
            })(this, e, t, r))
          : null !== o.match(/^Dictionary$/gi)
          ? (n = ((e, {type}, r, n) => {
              if ("object" != typeof r)
                throw new Error(`${n} must be of type object.`);
              const o = type.value;
              if (!o || "object" != typeof o)
                throw new Error(
                  `"value" metadata for a Dictionary must be defined in the mapper and it must of type "object" in ${n}.`
                );
              for (
                var i = {}, a = 0, s = Object.keys(r);
                a < s.length;
                a++
              ) {
                const u = s[a];
                i[u] = e.serialize(o, r[u], `${n}.${u}`);
              }
              return i;
            })(this, e, t, r))
          : null !== o.match(/^Composite$/gi) &&
            (n = ((e, t, r, n) => {
              let o;
              if ((M(e, t) && (t = H(e, t, r, "clientName")), null == r))
                return r;
              for (
                var i = {}, a = U(e, t, n), s = 0, u = Object.keys(a);
                s < u.length;
                s++
              ) {
                const l = u[s];
                const c = a[l];
                if (!c.readOnly) {
                  let f = void 0;
                  let p = i;
                  if (e.isXML)
                    f = c.xmlIsWrapped
                      ? c.xmlName
                      : c.xmlElementName || c.xmlName;
                  else {
                    const h = I(c.serializedName);
                    f = h.pop();
                    for (let d = 0, y = h; d < y.length; d++) {
                      const m = y[d];
                      null == p[m] && null != r[l] && (p[m] = {}),
                        (p = p[m]);
                    }
                  }
                  if (null != p) {
                    const v =
                        "" !== c.serializedName
                          ? `${n}.${c.serializedName}`
                          : n;

                    let g = r[l];
                    const b = M(e, t);
                    b &&
                      b.clientName === l &&
                      null == g &&
                      (g = t.serializedName);
                    const w = e.serialize(c, g, v);
                    void 0 !== w &&
                      null != f &&
                      (c.xmlIsAttribute
                        ? ((p.$ = p.$ || {}), (p.$[f] = w))
                        : c.xmlIsWrapped
                        ? (p[f] = (((o = {})[c.xmlElementName] = w), o))
                        : (p[f] = w));
                  }
                }
              }
              const E = t.type.additionalProperties;
              if (E) {
                const R = Object.keys(a);

                const T = t => {
                  R.every(e => {
                    return e !== t;
                  }) &&
                    (i[t] = e.serialize(E, r[t], `${n}["${t}"]`));
                };

                for (const _ in r) T(_);
              }
              return i;
            })(this, e, t, r))),
    n;
  }),
    (R.prototype.deserialize = function (e, t, r) {
    if (null == t)
      return (
        this.isXML &&
          "Sequence" === e.type.name &&
          !e.xmlIsWrapped &&
          (t = []),
        t
      );
    let n;
    let o;
    const i = e.type.name;
    return (r = r || e.serializedName),
    null !== i.match(/^Composite$/gi)
      ? (n = ((e, t, r, n) => {
          M(e, t) && (t = H(e, t, r, "serializedName"));
          for (
            var o = U(e, t, n), i = {}, a = [], s = 0, u = Object.keys(o);
            s < u.length;
            s++
          ) {
            var l = u[s];
            const c = o[l];
            const f = I(o[l].serializedName);
            a.push(f[0]);
            const p = c.serializedName;
            const h = c.xmlName;
            const d = c.xmlElementName;
            let y = n;
            "" !== p && void 0 !== p && (y = `${n}.${p}`);
            const m = c.headerCollectionPrefix;
            if (m) {
              for (
                var v = {}, g = 0, b = Object.keys(r);
                g < b.length;
                g++
              ) {
                const w = b[g];
                w.startsWith(m) &&
                  (v[w.substring(m.length)] = e.deserialize(
                    c.type.value,
                    r[w],
                    y
                  )),
                  a.push(w);
              }
              i[l] = v;
            } else if (e.isXML)
              if (c.xmlIsAttribute && r.$)
                i[l] = e.deserialize(c, r.$[h], y);
              else {
                let E = r[d || h || p];
                c.xmlIsWrapped &&
                  void 0 === (E = (E = r[h]) && E[d]) &&
                  (E = []),
                  (i[l] = e.deserialize(c, E, y));
              }
            else {
              for (var R = void 0, T = r, _ = 0, P = f; _ < P.length; _++) {
                const S = P[_];
                if (!T) break;
                T = T[S];
              }
              R = T;
              const O = t.type.polymorphicDiscriminator;
              O &&
                c.serializedName === O.serializedName &&
                null == R &&
                (R = t.serializedName);
              let x = void 0;
              Array.isArray(r[l]) && "" === o[l].serializedName
                ? ((R = r[l]), (i = e.deserialize(c, R, y)))
                : void 0 !== R &&
                  ((x = e.deserialize(c, R, y)), (i[l] = x));
            }
          }
          const N = t.type.additionalProperties;
          if (N) {
            const q = e => {
              for (const t in o)
                if (I(o[t].serializedName)[0] === e) return !1;
              return !0;
            };
            for (const A in r)
              q(A) && (i[A] = e.deserialize(N, r[A], `${n}["${A}"]`));
          } else if (r)
            for (let C = 0, D = Object.keys(r); C < D.length; C++)
              (l = D[C]),
                void 0 !== i[l] ||
                  a.includes(l) ||
                  ["$", "_"].includes(l) ||
                  (i[l] = r[l]);
          return i;
        })(this, e, t, r))
      : (this.isXML && null != t.$ && null != t._ && (t = t._),
        null !== i.match(/^Number$/gi)
          ? ((n = parseFloat(t)), isNaN(n) && (n = t))
          : null !== i.match(/^Boolean$/gi)
          ? (n = "true" === t || ("false" !== t && t))
          : null !==
            i.match(/^(String|Enum|Object|Stream|Uuid|TimeSpan|any)$/gi)
          ? (n = t)
          : null !== i.match(/^(Date|DateTime|DateTimeRfc1123)$/gi)
          ? (n = new Date(t))
          : null !== i.match(/^UnixTime$/gi)
          ? (n = (o = t) ? new Date(1e3 * o) : void 0)
          : null !== i.match(/^ByteArray$/gi)
          ? (n = a(t))
          : null !== i.match(/^Base64Url$/gi)
          ? (n = (e => {
              if (e) {
                if (e && "string" != typeof e.valueOf())
                  throw new Error(
                    "Please provide an input of type string for converting to Uint8Array"
                  );
                return a((e = e.replace(/\-/g, "+").replace(/\_/g, "/")));
              }
            })(t))
          : null !== i.match(/^Sequence$/gi)
          ? (n = ((e, {type}, r, n) => {
              const o = type.element;
              if (!o || "object" != typeof o)
                throw new Error(
                  `element" metadata for an Array must be defined in the mapper and it must of type "object" in ${n}`
                );
              if (r) {
                Array.isArray(r) || (r = [r]);
                for (var i = [], a = 0; a < r.length; a++)
                  i[a] = e.deserialize(o, r[a], `${n}[${a}]`);
                return i;
              }
              return r;
            })(this, e, t, r))
          : null !== i.match(/^Dictionary$/gi) &&
            (n = ((e, {type}, r, n) => {
              const o = type.value;
              if (!o || "object" != typeof o)
                throw new Error(
                  `"value" metadata for a Dictionary must be defined in the mapper and it must of type "object" in ${n}`
                );
              if (r) {
                for (
                  var i = {}, a = 0, s = Object.keys(r);
                  a < s.length;
                  a++
                ) {
                  const u = s[a];
                  i[u] = e.deserialize(o, r[u], n);
                }
                return i;
              }
              return r;
            })(this, e, t, r))),
    e.isConstant && (n = e.defaultValue),
    n;
  }),
    R);
  function R(e, t) {
    void 0 === e && (e = {}), (this.modelMappers = e), (this.isXML = t);
  }
  function I(e) {
    const t = [];
    let r = "";
    if (e)
      for (let n = 0, o = e.split("."); n < o.length; n++) {
        const i = o[n];
        "\\" === i.charAt(i.length - 1)
          ? (r += `${i.substr(0, i.length - 1)}.`)
          : ((r += i), t.push(r), (r = ""));
      }
    return t;
  }
  function U({modelMappers}, t, r) {
    let n = t.type.modelProperties;
    if (!n) {
      const o = t.type.className;
      if (!o)
        throw new Error(
          `Class name for model "${r}" is not provided in the mapper "${JSON.stringify(t, void 0, 2)}".`
        );
      const i = modelMappers[o];
      if (!i)
        throw new Error(
          `mapper() cannot be null or undefined for model "${o}".`
        );
      if (!(n = i.type.modelProperties))
        throw new Error(
          `modelProperties cannot be null or undefined in the mapper "${JSON.stringify(i)}" of type "${o}" for object "${r}".`
        );
    }
    return n;
  }
  function H(e, t, r, n) {
    const o = M(e, t);
    if (o) {
      const i = o[n];
      if (null != i) {
        const a = r[i];
        if (null != a) {
          const s = t.type.uberParent || t.type.className;
          const u = a === s ? a : `${s}.${a}`;
          const l = e.modelMappers.discriminators[u];
          l && (t = l);
        }
      }
    }
    return t;
  }
  function M(e, {type}) {
    return type.polymorphicDiscriminator ||
    T(e, type.uberParent) ||
    T(e, type.className);
  }
  function T({modelMappers}, t) {
    return t && modelMappers[t] && modelMappers[t].type.polymorphicDiscriminator;
  }

  const q = (e => {
            for (var t = {}, r = 0, n = e; r < n.length; r++) {
              const o = n[r];
              t[o] = o;
            }
            return t;
          })([
            "Base64Url",
            "Boolean",
            "ByteArray",
            "Composite",
            "Date",
            "DateTime",
            "DateTimeRfc1123",
            "Dictionary",
            "Enum",
            "Number",
            "Object",
            "Sequence",
            "String",
            "Stream",
            "TimeSpan",
            "UnixTime",
          ]);

  const A =
    ((_.prototype.validateRequestProperties = function () {
      if (!this.method) throw new Error("WebResource.method is required.");
      if (!this.url) throw new Error("WebResource.url is required.");
    }),
    (_.prototype.prepare = function (e) {
      if (!e) throw new Error("options object is required");
      if (null == e.method || "string" != typeof e.method.valueOf())
        throw new Error("options.method must be a string.");
      if (e.url && e.pathTemplate)
        throw new Error(
          "options.url and options.pathTemplate are mutually exclusive. Please provide exactly one of them."
        );
      if (
        !(
          (null != e.pathTemplate &&
            "string" == typeof e.pathTemplate.valueOf()) ||
          (null != e.url && "string" == typeof e.url.valueOf())
        )
      )
        throw new Error(
          "Please provide exactly one of options.pathTemplate or options.url."
        );
      if (e.url) {
        if ("string" != typeof e.url)
          throw new Error('options.url must be of type "string".');
        this.url = e.url;
      }
      if (e.method) {
        const t = [
          "GET",
          "PUT",
          "HEAD",
          "DELETE",
          "OPTIONS",
          "POST",
          "PATCH",
          "TRACE",
        ];
        if (!t.includes(e.method.toUpperCase()))
          throw new Error(
            `The provided method "${e.method}" is invalid. Supported HTTP methods are: ${JSON.stringify(t)}`
          );
      }
      if (((this.method = e.method.toUpperCase()), e.pathTemplate)) {
        const n = e.pathTemplate, o = e.pathParameters;
        if ("string" != typeof n)
          throw new Error('options.pathTemplate must be of type "string".');
        e.baseUrl || (e.baseUrl = "https://management.azure.com");
        const r = e.baseUrl;

        let i =
          r +
          (r.endsWith("/") ? "" : "/") +
          (n.startsWith("/") ? n.slice(1) : n);

        const a = i.match(/({\w*\s*\w*})/gi);
        if (a && a.length) {
          if (!o)
            throw new Error(
              `pathTemplate: ${n} has been provided. Hence, options.pathParameters must also be provided.`
            );
          a.forEach(e => {
            const t = e.slice(1, -1), r = o[t];
            if (null == r || ("string" != typeof r && "object" != typeof r))
              throw new Error(
                `pathTemplate: ${n} contains the path parameter ${t} however, it is not present in ${o} - ${JSON.stringify(o, void 0, 2)}.The value of the path parameter can either be a "string" of the form { ${t}: "some sample value" } or it can be an "object" of the form { "${t}": { value: "some sample value", skipUrlEncoding: true } }.`
              );
            if (
              ("string" == typeof r.valueOf() &&
                (i = i.replace(e, encodeURIComponent(r))),
              "object" == typeof r.valueOf())
            ) {
              if (!r.value)
                throw new Error(
                  `options.pathParameters[${t}] is of type "object" but it does not contain a "value" property.`
                );
              i = r.skipUrlEncoding
                ? i.replace(e, r.value)
                : i.replace(e, encodeURIComponent(r.value));
            }
          });
        }
        this.url = i;
      }
      if (e.queryParameters) {
        const s = e.queryParameters;
        if ("object" != typeof s)
          throw new Error(
            'options.queryParameters must be of type object. It should be a JSON object of "query-parameter-name" as the key and the "query-parameter-value" as the value. The "query-parameter-value" may be fo type "string" or an "object" of the form { value: "query-parameter-value", skipUrlEncoding: true }.'
          );
        this.url && !this.url.includes("?") && (this.url += "?");
        const u = [];
        for (const l in ((this.query = {}), s)) {
          const c = s[l];
          if (c)
            if ("string" == typeof c)
              u.push(`${l}=${encodeURIComponent(c)}`),
                (this.query[l] = encodeURIComponent(c));
            else if ("object" == typeof c) {
              if (!c.value)
                throw new Error(
                  `options.queryParameters[${l}] is of type "object" but it does not contain a "value" property.`
                );
              c.skipUrlEncoding
                ? (u.push(`${l}=${c.value}`), (this.query[l] = c.value))
                : (u.push(`${l}=${encodeURIComponent(c.value)}`),
                  (this.query[l] = encodeURIComponent(c.value)));
            }
        }
        this.url += u.join("&");
      }
      if (e.headers)
        for (
          let f = e.headers, p = 0, h = Object.keys(e.headers);
          p < h.length;
          p++
        ) {
          const d = h[p];
          this.headers.set(d, f[d]);
        }
      return (
        this.headers.get("accept-language") ||
          this.headers.set("accept-language", "en-US"),
        this.headers.get("x-ms-client-request-id") ||
          e.disableClientRequestId ||
          this.headers.set("x-ms-client-request-id", y()),
        this.headers.get("Content-Type") ||
          this.headers.set("Content-Type", "application/json; charset=utf-8"),
        (this.body = e.body),
        null != e.body &&
          (e.bodyIsStream
            ? (this.headers.get("Transfer-Encoding") ||
                this.headers.set("Transfer-Encoding", "chunked"),
              "application/octet-stream" !==
                this.headers.get("Content-Type") &&
                this.headers.set("Content-Type", "application/octet-stream"))
            : (e.serializationMapper &&
                (this.body = new E(e.mappers).serialize(
                  e.serializationMapper,
                  e.body,
                  "requestBody"
                )),
              e.disableJsonStringifyOnBody ||
                (this.body = JSON.stringify(e.body)))),
        (this.abortSignal = e.abortSignal),
        (this.onDownloadProgress = e.onDownloadProgress),
        (this.onUploadProgress = e.onUploadProgress),
        this
      );
    }),
    (_.prototype.clone = function () {
      const e = new _(
        this.url,
        this.method,
        this.body,
        this.query,
        this.headers && this.headers.clone(),
        this.streamResponseBody,
        this.withCredentials,
        this.abortSignal,
        this.timeout,
        this.onUploadProgress,
        this.onDownloadProgress,
        this.proxySettings,
        this.keepAlive,
        this.agentSettings
      );
      return (
        this.formData && (e.formData = this.formData),
        this.operationSpec && (e.operationSpec = this.operationSpec),
        this.shouldDeserialize &&
          (e.shouldDeserialize = this.shouldDeserialize),
        this.operationResponseGetter &&
          (e.operationResponseGetter = this.operationResponseGetter),
        e
      );
    }),
    _);

  function _(e, t, r, n, o, i, a, s, u, l, c, f, p, h) {
    (this.streamResponseBody = i),
      (this.url = e || ""),
      (this.method = t || "GET"),
      (this.headers = o instanceof d ? o : new d(o)),
      (this.body = r),
      (this.query = n),
      (this.formData = void 0),
      (this.withCredentials = a || !1),
      (this.abortSignal = s),
      (this.timeout = u || 0),
      (this.onUploadProgress = l),
      (this.onDownloadProgress = c),
      (this.proxySettings = f),
      (this.keepAlive = p),
      (this.agentSettings = h);
  }
  let P = (e, t) => {
    return (P =
      Object.setPrototypeOf ||
      ({ __proto__: [] } instanceof Array &&
        ((e, t) => {
          e.__proto__ = t;
        })) ||
      ((e, t) => {
        for (const r in t) t.hasOwnProperty(r) && (e[r] = t[r]);
      }))(e, t);
  };
  function S(e, t) {
    function r() {
      this.constructor = e;
    }
    P(e, t),
      (e.prototype =
        null === t ? Object.create(t) : ((r.prototype = t.prototype), new r()));
  }
  let O = function(...args) {
    return (O =
      Object.assign ||
      function (e) {
        for (let t, r = 1, n = arguments.length; r < n; r++)
          for (const o in (t = arguments[r]))
            Object.prototype.hasOwnProperty.call(t, o) && (e[o] = t[o]);
        return e;
      }).apply(this, args);
  };
  function x(i, a, s, u) {
    return new (s = s || Promise)((e, t) => {
      function r(e) {
        try {
          o(u.next(e));
        } catch (e) {
          t(e);
        }
      }
      function n(e) {
        try {
          o(u.throw(e));
        } catch (e) {
          t(e);
        }
      }
      function o({done, value}) {
        done
          ? e(value)
          : new s(e => {
              e(value);
            }).then(r, n);
      }
      o((u = u.apply(i, a || [])).next());
    });
  }
  function C(r, n) {
    let o;
    let i;
    let a;
    let e;

    let s = {
      label: 0,
      sent() {
        if (1 & a[0]) throw a[1];
        return a[1];
      },
      trys: [],
      ops: [],
    };

    return (
      (e = { next: t(0), throw: t(1), return: t(2) }),
      "function" == typeof Symbol &&
        (e[Symbol.iterator] = function () {
          return this;
        }),
      e
    );
    function t(t) {
      return e => {
        return (t => {
          if (o) throw new TypeError("Generator is already executing.");
          for (; s; )
            try {
              if (
                ((o = 1),
                i &&
                  (a =
                    2 & t[0]
                      ? i.return
                      : t[0]
                      ? i.throw || ((a = i.return) && a.call(i), 0)
                      : i.next) &&
                  !(a = a.call(i, t[1])).done)
              )
                return a;
              switch (((i = 0), a && (t = [2 & t[0], a.value]), t[0])) {
                case 0:
                case 1:
                  a = t;
                  break;
                case 4:
                  return s.label++, { value: t[1], done: !1 };
                case 5:
                  s.label++, (i = t[1]), (t = [0]);
                  continue;
                case 7:
                  (t = s.ops.pop()), s.trys.pop();
                  continue;
                default:
                  if (
                    !(a = 0 < (a = s.trys).length && a[a.length - 1]) &&
                    (6 === t[0] || 2 === t[0])
                  ) {
                    s = 0;
                    continue;
                  }
                  if (3 === t[0] && (!a || (t[1] > a[0] && t[1] < a[3]))) {
                    s.label = t[1];
                    break;
                  }
                  if (6 === t[0] && s.label < a[1]) {
                    (s.label = a[1]), (a = t);
                    break;
                  }
                  if (a && s.label < a[2]) {
                    (s.label = a[2]), s.ops.push(t);
                    break;
                  }
                  a[2] && s.ops.pop(), s.trys.pop();
                  continue;
              }
              t = n.call(r, s);
            } catch (e) {
              (t = [6, e]), (i = 0);
            } finally {
              o = a = 0;
            }
          if (5 & t[0]) throw t[1];
          return { value: t[0] ? t[1] : void 0, done: !0 };
        })([t, e]);
      };
    }
  }
  let D;

  const z =
    (S(j, (D = Error)),
    (j.REQUEST_SEND_ERROR = "REQUEST_SEND_ERROR"),
    (j.REQUEST_ABORTED_ERROR = "REQUEST_ABORTED_ERROR"),
    (j.PARSE_ERROR = "PARSE_ERROR"),
    j);

  function j(e, t, r, n, o, i) {
    const a = D.call(this, e) || this;
    return (
      (a.code = t),
      (a.statusCode = r),
      (a.request = n),
      (a.response = o),
      (a.body = i),
      Object.setPrototypeOf(a, j.prototype),
      a
    );
  }
  let k;

  const L =
    ((B.prototype.sendRequest = r => {
      const n = new XMLHttpRequest();
      if (r.agentSettings)
        throw new Error(
          "HTTP agent settings not supported in browser environment"
        );
      if (r.proxySettings)
        throw new Error("HTTP proxy is not supported in browser environment");
      const e = r.abortSignal;
      if (e) {
        const t = () => {
          n.abort();
        };
        e.addEventListener("abort", t),
          n.addEventListener("readystatechange", () => {
            n.readyState === XMLHttpRequest.DONE &&
              e.removeEventListener("abort", t);
          });
      }
      if (
        (F(n.upload, r.onUploadProgress),
        F(n, r.onDownloadProgress),
        r.formData)
      ) {
        for (
          var o = r.formData,
            i = new FormData(),
            a = (e, t) => {
              t && t.hasOwnProperty("value") && t.hasOwnProperty("options")
                ? i.append(e, t.value, t.options)
                : i.append(e, t);
            },
            s = 0,
            u = Object.keys(o);
          s < u.length;
          s++
        ) {
          const l = u[s];
          const c = o[l];
          if (Array.isArray(c)) for (let f = 0; f < c.length; f++) a(l, c[f]);
          else a(l, c);
        }
        (r.body = i), (r.formData = void 0);
        const p = r.headers.get("Content-Type");
        p &&
          p.includes("multipart/form-data") &&
          r.headers.remove("Content-Type");
      }
      n.open(r.method, r.url),
        (n.timeout = r.timeout),
        (n.withCredentials = r.withCredentials);
      for (let h = 0, d = r.headers.headersArray(); h < d.length; h++) {
        const y = d[h];
        n.setRequestHeader(y.name, y.value);
      }
      return (n.responseType = r.streamResponseBody ? "blob" : "text"),
      n.send(void 0 === r.body ? null : r.body),
      r.streamResponseBody
        ? new Promise((t, e) => {
            n.addEventListener("readystatechange", () => {
              if (n.readyState === XMLHttpRequest.HEADERS_RECEIVED) {
                const e = new Promise((e, t) => {
                  n.addEventListener("load", () => {
                    e(n.response);
                  }),
                    Q(r, n, t);
                });
                t({
                  request: r,
                  status: n.status,
                  headers: $(n),
                  blobBody: e,
                });
              }
            }),
              Q(r, n, e);
          })
        : new Promise((e, t) => {
            n.addEventListener("load", () => {
              return e({
                request: r,
                status: n.status,
                headers: $(n),
                bodyAsText: n.responseText,
              });
            }),
              Q(r, n, t);
          });
    }),
    B);

  function B() {}
  function F(e, t) {
    t &&
      e.addEventListener("progress", ({loaded}) => {
        return t({ loadedBytes: loaded });
      });
  }
  function $(e) {
    for (
      var t = new d(),
        r = 0,
        n = e
          .getAllResponseHeaders()
          .trim()
          .split(/[\r\n]+/);
      r < n.length;
      r++
    ) {
      const o = n[r];
      const i = o.indexOf(":");
      const a = o.slice(0, i);
      const s = o.slice(i + 2);
      t.set(a, s);
    }
    return t;
  }
  function Q(e, t, r) {
    t.addEventListener("error", () => {
      return r(
        new z(
          `Failed to send request to ${e.url}`,
          z.REQUEST_SEND_ERROR,
          void 0,
          e
        )
      );
    }),
      t.addEventListener("abort", () => {
        return r(
          new z("The request was aborted", z.REQUEST_ABORTED_ERROR, void 0, e)
        );
      }),
      t.addEventListener("timeout", () => {
        return r(
          new z(
            `timeout of ${t.timeout}ms exceeded`,
            z.REQUEST_SEND_ERROR,
            void 0,
            e
          )
        );
      });
  }
  function V({parameterPath, mapper}) {
    return Y(parameterPath, mapper);
  }
  function Y(e, {serializedName}) {
    return "string" == typeof e
      ? e
      : Array.isArray(e)
      ? e.join(".")
      : serializedName;
  }
  function X({responses}) {
    let t = !1;
    for (const r in responses) {
      const n = responses[r];
      if (n.bodyMapper && n.bodyMapper.type.name === q.Stream) {
        t = !0;
        break;
      }
    }
    return t;
  }
  ((k = N.HttpPipelineLogLevel || (N.HttpPipelineLogLevel = {}))[(k.OFF = 0)] =
    "OFF"),
    (k[(k.ERROR = 1)] = "ERROR"),
    (k[(k.WARNING = 2)] = "WARNING"),
    (k[(k.INFO = 3)] = "INFO");
  const W = new DOMParser();
  function J(e) {
    try {
      const t = W.parseFromString(e, "application/xml");
      !(e => {
        if (G) {
          const t = e.getElementsByTagNameNS(G, "parsererror");
          if (t.length) throw new Error(t.item(0).innerHTML);
        }
      })(t);
      const r = (function e(t) {
        let r = {};
        const n = t.childNodes.length;
        const o = t.childNodes[0];
        const i =
          (o && 1 === n && o.nodeType === Node.TEXT_NODE && o.nodeValue) ||
          void 0;
        const a =
          ((s = t),
          (({attributes}) => {
            return !!attributes;
          })(s) && s.hasAttributes()
            ? s
            : void 0);
        var s;
        if (a) {
          r.$ = {};
          for (var u = 0; u < a.attributes.length; u++) {
            const l = a.attributes[u];
            r.$[l.nodeName] = l.nodeValue;
          }
          i && (r._ = i);
        } else 0 === n ? (r = "") : i && (r = i);
        if (!i)
          for (var u = 0; u < n; u++) {
            const c = t.childNodes[u];
            if (c.nodeType !== Node.TEXT_NODE) {
              const f = e(c);
              r[c.nodeName]
                ? Array.isArray(r[c.nodeName])
                  ? r[c.nodeName].push(f)
                  : (r[c.nodeName] = [r[c.nodeName], f])
                : (r[c.nodeName] = f);
            }
          }
        return r;
      })(t.childNodes[0]);
      return Promise.resolve(r);
    } catch (e) {
      return Promise.reject(e);
    }
  }
  var G = "";
  try {
    G = W.parseFromString("INVALID", "text/xml").getElementsByTagName(
      "parsererror"
    )[0].namespaceURI;
  } catch (e) {}
  const K = document.implementation.createDocument(null, null, null);
  const Z = new XMLSerializer();
  function ee(e, t) {
    const r = (function e(t, r) {
      {
        if (
          "string" == typeof t ||
          "number" == typeof t ||
          "boolean" == typeof t
        ) {
          var n = K.createElement(r);
          return (n.textContent = t.toString()), [n];
        }
        if (Array.isArray(t)) {
          for (var o = [], i = 0, a = t; i < a.length; i++)
            for (let s = a[i], u = 0, l = e(s, r); u < l.length; u++) {
              var c = l[u];
              o.push(c);
            }
          return o;
        }
        if ("object" != typeof t)
          throw new Error(`Illegal value passed to buildObject: ${t}`);
        for (
          let n = K.createElement(r), f = 0, p = Object.keys(t);
          f < p.length;
          f++
        ) {
          const h = p[f];
          if ("$" === h)
            for (let d = 0, y = te(t[h]); d < y.length; d++) {
              const m = y[d];
              n.attributes.setNamedItem(m);
            }
          else
            for (let v = 0, g = e(t[h], h); v < g.length; v++) {
              var c = g[v];
              n.appendChild(c);
            }
        }
        return [n];
      }
    })(e, (t && t.rootName) || "root")[0];
    return `<?xml version="1.0" encoding="UTF-8" standalone="yes"?>${Z.serializeToString(r)}`;
  }
  function te(e) {
    for (var t = [], r = 0, n = Object.keys(e); r < n.length; r++) {
      const o = n[r];
      const i = K.createAttribute(o);
      (i.value = e[o].toString()), t.push(i);
    }
    return t;
  }
  const re =
    ((ne.prototype.shouldLog = function (e) {
      return this._options.shouldLog(e);
    }),
    (ne.prototype.log = function (e, t) {
      this._options.log(e, t);
    }),
    ne);
  function ne(e, t) {
    (this._nextPolicy = e), (this._options = t);
  }
  const oe =
    ((ie.prototype.shouldLog = function (e) {
      return (
        !!this._logger &&
        e !== N.HttpPipelineLogLevel.OFF &&
        e <= this._logger.minimumLogLevel
      );
    }),
    (ie.prototype.log = function (e, t) {
      this._logger && this.shouldLog(e) && this._logger.log(e, t);
    }),
    ie);
  function ie(e) {
    this._logger = e;
  }
  function ae(r) {
    return {
      create(e, t) {
        return new ce(e, r, t);
      },
    };
  }
  let se;
  const ue = ["application/json", "text/json"];
  const le = ["application/xml", "application/atom+xml"];

  var ce =
    (S(fe, (se = re)),
    (fe.prototype.sendRequest = function (r) {
      return x(this, void 0, void 0, function () {
        const t = this;
        return C(this, function (e) {
          return [
            2,
            this._nextPolicy.sendRequest(r).then(e => {
              return pe(t.jsonContentTypes, t.xmlContentTypes, e);
            }),
          ];
        });
      });
    }),
    fe);

  function fe(e, t, r) {
    const n = se.call(this, e, r) || this;
    return (
      (n.jsonContentTypes = (t && t.json) || ue),
      (n.xmlContentTypes = (t && t.xml) || le),
      n
    );
  }
  function pe(e, t, m) {
    return ((t, r, o) => {
      function e(e) {
        const t =
                  `Error "${e}" occurred while parsing the response body - ${o.bodyAsText}.`;

        const r = e.code || z.PARSE_ERROR;
        const n = new z(t, r, o.status, o.request, o, o.bodyAsText);
        return Promise.reject(n);
      }
      if (!o.request.streamResponseBody && o.bodyAsText) {
        const n = o.bodyAsText;
        const i = o.headers.get("Content-Type") || "";

        const a = i
          ? i.split(";").map(e => {
              return e.toLowerCase();
            })
          : [];

        if (
          0 === a.length ||
          a.some(e => {
            return t.includes(e);
          })
        )
          return new Promise(e => {
            (o.parsedBody = JSON.parse(n)), e(o);
          }).catch(e);
        if (
          a.some(e => {
            return r.includes(e);
          })
        )
          return J(n)
            .then(e => {
              return (o.parsedBody = e), o;
            })
            .catch(e);
      }
      return Promise.resolve(o);
    })(e, t, m).then(t => {
      let e;
      let r;
      if (
        void 0 === (r = (e = t).request.shouldDeserialize) ||
        ("boolean" == typeof r ? r : r(e))
      ) {
        const n = t.request.operationSpec;
        if (n && n.responses) {
          const o = t.status;
          const i = Object.keys(n.responses);
          const a = 0 === i.length || (1 === i.length && "default" === i[0]);

          const s = (e => {
            let t;
            const r = e.request;
            const n = r.operationSpec;
            if (n) {
              const o = r.operationResponseGetter;
              t = o ? o(n, e) : n.responses[e.status];
            }
            return t;
          })(t);

          if (a ? 200 <= o && o < 300 : !!s) {
            if (s) {
              if (s.bodyMapper) {
                y = t.parsedBody;
                n.isXML &&
                  s.bodyMapper.type.name === q.Sequence &&
                  (y =
                    "object" == typeof y ? y[s.bodyMapper.xmlElementName] : []);
                try {
                  t.parsedBody = n.serializer.deserialize(
                    s.bodyMapper,
                    y,
                    "operationRes.parsedBody"
                  );
                } catch (f) {
                  const u = new z(
                    `Error ${f} occurred in deserializing the responseBody - ${t.bodyAsText}`
                  );
                  return (
                    (u.request = g(t.request)),
                    (u.response = v(t)),
                    Promise.reject(u)
                  );
                }
              } else
                "HEAD" === n.httpMethod &&
                  (t.parsedBody = 200 <= m.status && m.status < 300);
              s.headersMapper &&
                (t.parsedHeaders = n.serializer.deserialize(
                  s.headersMapper,
                  t.headers.rawHeaders(),
                  "operationRes.parsedHeaders"
                ));
            }
          } else {
            const l = n.responses.default;
            if (l) {
              const c = X(n) ? `Unexpected status code: ${o}` : t.bodyAsText;
              var f = new z(c);
              (f.statusCode = o),
                (f.request = g(t.request)),
                (f.response = v(t));
              let p = t.parsedBody;
              try {
                if (p) {
                  const h = l.bodyMapper;
                  if (h && "CloudError" === h.serializedName)
                    p.error && (p = p.error),
                      p.code && (f.code = p.code),
                      p.message && (f.message = p.message);
                  else {
                    let d = p;
                    p.error && (d = p.error),
                      (f.code = d.code),
                      d.message && (f.message = d.message);
                  }
                  if (h) {
                    var y = p;
                    n.isXML &&
                      h.type.name === q.Sequence &&
                      (y = "object" == typeof p ? p[h.xmlElementName] : []),
                      (f.body = n.serializer.deserialize(h, y, "error.body"));
                  }
                }
              } catch (e) {
                f.message =
                  `Error "${e.message}" occurred in deserializing the responseBody - "${t.bodyAsText}" for the default response.`;
              }
              return Promise.reject(f);
            }
          }
        }
      }
      return Promise.resolve(t);
    });
  }
  function he(r, n, o, i) {
    return {
      create(e, t) {
        return new ye(e, t, r, n, o, i);
      },
    };
  }
  let de;

  var ye =
    (S(me, (de = re)),
    (me.prototype.sendRequest = function (t) {
      const r = this;
      return this._nextPolicy
        .sendRequest(t.clone())
        .then(e => {
          return ve(r, t, e);
        })
        .catch(e => {
          return ve(r, t, e.response, void 0, e);
        });
    }),
    me);

  function me(e, t, r, n, o, i) {
    const a = de.call(this, e, t) || this;
    function s(e) {
      return "number" == typeof e;
    }
    return (
      (a.retryCount = s(r) ? r : 3),
      (a.retryInterval = s(n) ? n : 3e4),
      (a.minRetryInterval = s(o) ? o : 3e3),
      (a.maxRetryInterval = s(i) ? i : 9e4),
      a
    );
  }
  function ve(t, r, n, o, e) {
    o = (({retryInterval, minRetryInterval, maxRetryInterval}, t, r) => {
      (t = t || { retryCount: 0, retryInterval: 0 }),
        r && (t.error && (r.innerError = t.error), (t.error = r)),
        t.retryCount++;
      let n = 2 ** t.retryCount - 1;
      return (n *=
        0.8 * retryInterval +
        Math.floor(
          Math.random() * (1.2 * retryInterval - 0.8 * retryInterval)
        )),
      (t.retryInterval = Math.min(
        minRetryInterval + n,
        maxRetryInterval
      )),
      t
    ;
    })(t, o, e);
    const i = r.abortSignal && r.abortSignal.aborted;
    if (
      !i && (({retryCount}, t, r) => {
        if (null == t || (t < 500 && 408 !== t) || 501 === t || 505 === t)
          return !1;
        if (!r)
          throw new Error(
            "retryData for the ExponentialRetryPolicyFilter cannot be null."
          );
        return (r && r.retryCount) < retryCount;
      })(t, n && n.status, o)
    )
      return h(o.retryInterval)
        .then(() => {
          return t._nextPolicy.sendRequest(r.clone());
        })
        .then(e => {
          return ve(t, r, e, o, void 0);
        })
        .catch(e => {
          return ve(t, r, n, o, e);
        });
    if (i || e || !n) {
      const a =
        o.error ||
        new z(
          "Failed to send the request.",
          z.REQUEST_SEND_ERROR,
          n && n.status,
          n && n.request,
          n
        );
      return Promise.reject(a);
    }
    return Promise.resolve(n);
  }
  function ge(r) {
    return void 0 === r && (r = "x-ms-client-request-id"),
    {
      create(e, t) {
        return new we(e, t, r);
      },
    }
  ;
  }
  let be;

  var we =
    (S(Ee, (be = re)),
    (Ee.prototype.sendRequest = function (e) {
      return (
        e.headers.contains(this._requestIdHeaderName) ||
          e.headers.set(this._requestIdHeaderName, y()),
        this._nextPolicy.sendRequest(e)
      );
    }),
    Ee);

  function Ee(e, t, r) {
    const n = be.call(this, e, t) || this;
    return (n._requestIdHeaderName = r), n;
  }
  function Re() {
    return "x-ms-command-name";
  }
  const Te = Re;
  function _e() {
    let e;
    let t;
    let r;
    let n;
    const o = [{ key: "ms-rest-js", value: c.msRestVersion }];

    const i = [
      {
        key: "OS",
        value: ((e = window.navigator).oscpu || e.platform).replace(" ", ""),
      },
    ];

    return (t = o.concat(i)),
    void 0 === r && (r = " "),
    void 0 === n && (n = "/"),
    t
      .map(({value, key}) => {
        const t = value ? `${n}${value}` : "";
        return key + t;
      })
      .join(r);
  }
  function Pe(e) {
    const r = e && null != e.key ? e.key : Re();
    const n = e && null != e.value ? e.value : _e();
    return {
      create(e, t) {
        return new Oe(e, t, r, n);
      },
    };
  }
  let Se;

  var Oe =
    (S(xe, (Se = re)),
    (xe.prototype.sendRequest = function (e) {
      return this.addUserAgentHeader(e), this._nextPolicy.sendRequest(e);
    }),
    (xe.prototype.addUserAgentHeader = function (e) {
      e.headers || (e.headers = new d()),
        !e.headers.get(this.headerKey) &&
          this.headerValue &&
          e.headers.set(this.headerKey, this.headerValue);
    }),
    xe);

  function xe(e, t, r, n) {
    const o = Se.call(this, e, t) || this;
    return (
      (o._nextPolicy = e),
      (o._options = t),
      (o.headerKey = r),
      (o.headerValue = n),
      o
    );
  }
  const Ne =
    ((qe.prototype.any = function () {
      return 0 < Object.keys(this._rawQuery).length;
    }),
    (qe.prototype.set = function (e, t) {
      if (e)
        if (null != t) {
          const r = Array.isArray(t) ? t : t.toString();
          this._rawQuery[e] = r;
        } else delete this._rawQuery[e];
    }),
    (qe.prototype.get = function (e) {
      return e ? this._rawQuery[e] : void 0;
    }),
    (qe.prototype.toString = function () {
      let e = "";
      for (const t in this._rawQuery) {
        e && (e += "&");
        const r = this._rawQuery[t];
        if (Array.isArray(r)) {
          for (var n = [], o = 0, i = r; o < i.length; o++) {
            const a = i[o];
            n.push(`${t}=${a}`);
          }
          e += n.join("&");
        } else e += `${t}=${r}`;
      }
      return e;
    }),
    (qe.parse = e => {
      const t = new qe();
      if (e) {
        e.startsWith("?") && (e = e.substring(1));
        for (
          var r = "ParameterName", n = "", o = "", i = 0;
          i < e.length;
          ++i
        ) {
          const a = e[i];
          switch (r) {
            case "ParameterName":
              switch (a) {
                case "=":
                  r = "ParameterValue";
                  break;
                case "&":
                  o = n = "";
                  break;
                default:
                  n += a;
              }
              break;
            case "ParameterValue":
              switch (a) {
                case "=":
                  (o = n = ""), (r = "Invalid");
                  break;
                case "&":
                  t.set(n, o), (o = n = ""), (r = "ParameterName");
                  break;
                default:
                  o += a;
              }
              break;
            case "Invalid":
              "&" === a && (r = "ParameterName");
              break;
            default:
              throw new Error(`Unrecognized URLQuery parse state: ${r}`);
          }
        }
        "ParameterValue" === r && t.set(n, o);
      }
      return t;
    }),
    qe);
  function qe() {
    this._rawQuery = {};
  }
  const Ae =
    ((Ce.prototype.setScheme = function (e) {
      e ? this.set(e, "SCHEME") : (this._scheme = void 0);
    }),
    (Ce.prototype.getScheme = function () {
      return this._scheme;
    }),
    (Ce.prototype.setHost = function (e) {
      e ? this.set(e, "SCHEME_OR_HOST") : (this._host = void 0);
    }),
    (Ce.prototype.getHost = function () {
      return this._host;
    }),
    (Ce.prototype.setPort = function (e) {
      null == e || "" === e
        ? (this._port = void 0)
        : this.set(e.toString(), "PORT");
    }),
    (Ce.prototype.getPort = function () {
      return this._port;
    }),
    (Ce.prototype.setPath = function (e) {
      e
        ? e.includes("://")
          ? this.set(e, "SCHEME")
          : this.set(e, "PATH")
        : (this._path = void 0);
    }),
    (Ce.prototype.appendPath = function (e) {
      if (e) {
        let t = this.getPath();
        t &&
          (t.endsWith("/") || (t += "/"),
          e.startsWith("/") && (e = e.substring(1)),
          (e = t + e)),
          this.set(e, "PATH");
      }
    }),
    (Ce.prototype.getPath = function () {
      return this._path;
    }),
    (Ce.prototype.setQuery = function (e) {
      this._query = e ? Ne.parse(e) : void 0;
    }),
    (Ce.prototype.setQueryParameter = function (e, t) {
      e && (this._query || (this._query = new Ne()), this._query.set(e, t));
    }),
    (Ce.prototype.getQueryParameterValue = function (e) {
      return this._query ? this._query.get(e) : void 0;
    }),
    (Ce.prototype.getQuery = function () {
      return this._query ? this._query.toString() : void 0;
    }),
    (Ce.prototype.set = function (e, t) {
      for (const r = new Ue(e, t); r.next(); ) {
        const n = r.current();
        if (n)
          switch (n.type) {
            case "SCHEME":
              this._scheme = n.text || void 0;
              break;
            case "HOST":
              this._host = n.text || void 0;
              break;
            case "PORT":
              this._port = n.text || void 0;
              break;
            case "PATH":
              const o = n.text || void 0;
              (this._path && "/" !== this._path && "/" === o) ||
                (this._path = o);
              break;
            case "QUERY":
              this._query = Ne.parse(n.text);
              break;
            default:
              throw new Error(`Unrecognized URLTokenType: ${n.type}`);
          }
      }
    }),
    (Ce.prototype.toString = function () {
      let e = "";
      return this._scheme && (e += `${this._scheme}://`),
      this._host && (e += this._host),
      this._port && (e += `:${this._port}`),
      this._path &&
        (this._path.startsWith("/") || (e += "/"), (e += this._path)),
      this._query && this._query.any() && (e += `?${this._query.toString()}`),
      e
    ;
    }),
    (Ce.prototype.replaceAll = function (e, t) {
      e &&
        (this.setScheme(w(this.getScheme(), e, t)),
        this.setHost(w(this.getHost(), e, t)),
        this.setPort(w(this.getPort(), e, t)),
        this.setPath(w(this.getPath(), e, t)),
        this.setQuery(w(this.getQuery(), e, t)));
    }),
    (Ce.parse = e => {
      const t = new Ce();
      return t.set(e, "SCHEME_OR_HOST"), t;
    }),
    Ce);
  function Ce() {}
  const De =
    ((Ie.scheme = e => {
      return new Ie(e, "SCHEME");
    }),
    (Ie.host = e => {
      return new Ie(e, "HOST");
    }),
    (Ie.port = e => {
      return new Ie(e, "PORT");
    }),
    (Ie.path = e => {
      return new Ie(e, "PATH");
    }),
    (Ie.query = e => {
      return new Ie(e, "QUERY");
    }),
    Ie);
  function Ie(e, t) {
    (this.text = e), (this.type = t);
  }
  var Ue =
    ((He.prototype.current = function () {
      return this._currentToken;
    }),
    (He.prototype.next = function () {
    if (Me(this))
      switch (this._currentState) {
        case "SCHEME":
          (i = (e => {
            return Le(e, e => {
              return (
                (48 <= (t = e.charCodeAt(0)) && t <= 57) ||
                (65 <= t && t <= 90) ||
                (97 <= t && t <= 122)
              );
              var t;
            });
          })(o = this)),
            (o._currentToken = De.scheme(i)),
            Me(o) ? (o._currentState = "HOST") : (o._currentState = "DONE");
          break;
        case "SCHEME_OR_HOST":
          (n = Be((r = this), ":", "/", "?")),
            Me(r)
              ? ":" === ze(r)
                ? "://" === ke(r, 3)
                  ? ((r._currentToken = De.scheme(n)),
                    (r._currentState = "HOST"))
                  : ((r._currentToken = De.host(n)),
                    (r._currentState = "PORT"))
                : ((r._currentToken = De.host(n)),
                  "/" === ze(r)
                    ? (r._currentState = "PATH")
                    : (r._currentState = "QUERY"))
              : ((r._currentToken = De.host(n)), (r._currentState = "DONE"));
          break;
        case "HOST":
          !(e => {
            "://" === ke(e, 3) && je(e, 3);
            const t = Be(e, ":", "/", "?");
            (e._currentToken = De.host(t)),
              Me(e)
                ? ":" === ze(e)
                  ? (e._currentState = "PORT")
                  : "/" === ze(e)
                  ? (e._currentState = "PATH")
                  : (e._currentState = "QUERY")
                : (e._currentState = "DONE");
          })(this);
          break;
        case "PORT":
          !(e => {
            ":" === ze(e) && je(e);
            const t = Be(e, "/", "?");
            (e._currentToken = De.port(t)),
              Me(e)
                ? "/" === ze(e)
                  ? (e._currentState = "PATH")
                  : (e._currentState = "QUERY")
                : (e._currentState = "DONE");
          })(this);
          break;
        case "PATH":
          (t = Be((e = this), "?")),
            (e._currentToken = De.path(t)),
            Me(e) ? (e._currentState = "QUERY") : (e._currentState = "DONE");
          break;
        case "QUERY":
          !(e => {
            "?" === ze(e) && je(e);
            const t = (e => {
              let t = "";
              return (
                e._currentIndex < e._textLength &&
                  ((t = e._text.substring(e._currentIndex)),
                  (e._currentIndex = e._textLength)),
                t
              );
            })(e);
            (e._currentToken = De.query(t)), (e._currentState = "DONE");
          })(this);
          break;
        default:
          throw new Error(
            `Unrecognized URLTokenizerState: ${this._currentState}`
          );
      }
    else this._currentToken = void 0;
    var e;
    var t;
    var r;
    var n;
    var o;
    var i;
    return !!this._currentToken;
  }),
    He);
  function He(e, t) {
    (this._text = e),
      (this._textLength = e ? e.length : 0),
      (this._currentState = null != t ? t : "SCHEME_OR_HOST"),
      (this._currentIndex = 0);
  }
  function Me({_currentIndex, _textLength}) {
    return _currentIndex < _textLength;
  }
  function ze({_text, _currentIndex}) {
    return _text[_currentIndex];
  }
  function je(e, t) {
    Me(e) && ((t = t || 1), (e._currentIndex += t));
  }
  function ke({_currentIndex, _textLength, _text}, t) {
    let r = _currentIndex + t;
    return _textLength < r && (r = _textLength),
    _text.substring(_currentIndex, r)
  ;
  }
  function Le(e, t) {
    for (var r = ""; Me(e); ) {
      const n = ze(e);
      if (!t(n)) break;
      (r += n), je(e);
    }
    return r;
  }
  function Be(e) {
    for (var t = [], r = 1; r < arguments.length; r++) t[r - 1] = arguments[r];
    return Le(e, e => {
      return !t.includes(e);
    });
  }
  function Fe(r) {
    return void 0 === r && (r = 20),
    {
      create(e, t) {
        return new Qe(e, t, r);
      },
    }
  ;
  }
  let $e;

  var Qe =
    (S(Ve, ($e = re)),
    (Ve.prototype.sendRequest = function (e) {
      const t = this;
      return this._nextPolicy.sendRequest(e).then(e => {
        return (function t(r, e, n) {
          const o = e.request;
          const i = e.status;
          const a = e.headers.get("location");
          if (
            a &&
            (300 === i || 307 === i || (303 === i && "POST" === o.method)) &&
            (!r.maxRetries || n < r.maxRetries)
          ) {
            const s = Ae.parse(o.url);
            return s.setPath(a),
            (o.url = s.toString()),
            303 === i && (o.method = "GET"),
            r._nextPolicy.sendRequest(o).then(e => {
              return t(r, e, n + 1);
            })
          ;
          }
          return Promise.resolve(e);
        })(t, e, 0);
      });
    }),
    Ve);

  function Ve(e, t, r) {
    void 0 === r && (r = 20);
    const n = $e.call(this, e, t) || this;
    return (n.maxRetries = r), n;
  }
  let Ye;

  const Xe =
    (S(We, (Ye = re)),
    (We.prototype.sendRequest = function (t) {
      const r = this;
      return this._nextPolicy.sendRequest(t.clone()).then(e => {
        return ((t, r, n) => {
          if (409 === n.status) {
            const e = (e => {
              let t;
              let r;
              if (e) {
                try {
                  r = JSON.parse(e);
                } catch (e) {}
                if (
                  r &&
                  r.error &&
                  r.error.message &&
                  r.error.code &&
                  "MissingSubscriptionRegistration" === r.error.code
                ) {
                  const n = r.error.message.match(/.*'(.*)'/i);
                  n && (t = n.pop());
                }
              }
              return t;
            })(n.bodyAsText);
            if (e) {
              const o = (e => {
                const t = e.match(/.*\/subscriptions\/[a-f0-9-]+\//gi);
                if (!t || !t[0])
                  throw new Error(
                    `Unable to extract subscriptionId from the given url - ${e}.`
                  );
                return t[0];
              })(r.url);
              return ((t, e, r, n) => {
                const o =
                          `${e}providers/${r}/register?api-version=2016-02-01`;

                const i = `${e}providers/${r}?api-version=2016-02-01`;
                const a = Je(n);
                return (a.method = "POST"),
                (a.url = o),
                t._nextPolicy.sendRequest(a).then(({status}) => {
                  if (200 !== status)
                    throw new Error(
                      `Autoregistration of ${r} failed. Please try registering manually.`
                    );
                  return (function r(n, o, i) {
                    const e = Je(i);
                    return (e.url = o),
                    (e.method = "GET"),
                    n._nextPolicy.sendRequest(e).then(({parsedBody}) => {
                      const t = parsedBody;
                      return !(
                        !parsedBody ||
                        !t.registrationState ||
                        "Registered" !== t.registrationState
                      ) ||
                      h(1e3 * n._retryTimeout).then(() => {
                        return r(n, o, i);
                      });
                    });
                  })(t, i, n);
                });
              })(t, o, e, r).catch(() => {
                  return !1;
                })
                .then(e => {
                  return e
                    ? (r.headers.set("x-ms-client-request-id", y()),
                      t._nextPolicy.sendRequest(r.clone()))
                    : n;
                });
            }
          }
          return Promise.resolve(n);
        })(r, t, e);
      });
    }),
    We);

  function We(e, t, r) {
    void 0 === r && (r = 30);
    const n = Ye.call(this, e, t) || this;
    return (n._retryTimeout = r), n;
  }
  function Je(e, t) {
    void 0 === t && (t = !1);
    const r = e.clone();
    return (
      t && (r.url = e.url),
      r.headers.set("x-ms-client-request-id", y()),
      r.headers.set("Content-Type", "application/json; charset=utf-8"),
      r
    );
  }
  function Ge(r) {
    return {
      create(e, t) {
        return new Ze(e, t, r);
      },
    };
  }
  let Ke;

  var Ze =
    (S(et, (Ke = re)),
    (et.prototype.signRequest = function (e) {
      return this.authenticationProvider.signRequest(e);
    }),
    (et.prototype.sendRequest = function (e) {
      const t = this;
      return this.signRequest(e).then(e => {
        return t._nextPolicy.sendRequest(e);
      });
    }),
    et);

  function et(e, t, r) {
    const n = Ke.call(this, e, t) || this;
    return (n.authenticationProvider = r), n;
  }
  function tt(r, n, o, i) {
    return {
      create(e, t) {
        return new ot(e, t, r, n, o, i);
      },
    };
  }
  let rt;
  let nt;

  var ot =
    (S(it, (rt = re)),
    (it.prototype.sendRequest = function (t) {
      const r = this;
      return this._nextPolicy.sendRequest(t.clone()).then(e => {
        return (function t(r, n, o, i, a) {
          return (i = st(r, i, a)),
          a &&
          a.code &&
          at(r, i) &&
          ("ETIMEDOUT" === a.code ||
            "ESOCKETTIMEDOUT" === a.code ||
            "ECONNREFUSED" === a.code ||
            "ECONNRESET" === a.code ||
            "ENOENT" === a.code)
            ? h(i.retryInterval)
                .then(() => {
                  return r._nextPolicy.sendRequest(n.clone());
                })
                .then(e => {
                  return t(r, n, e, i, a);
                })
                .catch(e => {
                  return t(r, n, o, i, e);
                })
            : null != a
            ? ((a = i.error), Promise.reject(a))
            : Promise.resolve(o)
        ;
        })(r, t, e);
      });
    }),
    it);

  function it(e, t, r, n, o, i) {
    const a = rt.call(this, e, t) || this;
    return (
      (a.DEFAULT_CLIENT_RETRY_INTERVAL = 3e4),
      (a.DEFAULT_CLIENT_RETRY_COUNT = 3),
      (a.DEFAULT_CLIENT_MAX_RETRY_INTERVAL = 9e4),
      (a.DEFAULT_CLIENT_MIN_RETRY_INTERVAL = 3e3),
      (a.retryCount = "number" == typeof r ? r : a.DEFAULT_CLIENT_RETRY_COUNT),
      (a.retryInterval =
        "number" == typeof n ? n : a.DEFAULT_CLIENT_RETRY_INTERVAL),
      (a.minRetryInterval =
        "number" == typeof o ? o : a.DEFAULT_CLIENT_MIN_RETRY_INTERVAL),
      (a.maxRetryInterval =
        "number" == typeof i ? i : a.DEFAULT_CLIENT_MAX_RETRY_INTERVAL),
      a
    );
  }
  function at({retryCount}, t) {
    if (!t)
      throw new Error(
        "retryData for the SystemErrorRetryPolicyFilter cannot be null."
      );
    return (t && t.retryCount) < retryCount;
  }
  function st({retryInterval, minRetryInterval, maxRetryInterval}, t, r) {
    (t = t || { retryCount: 0, retryInterval: 0 }),
      r && (t.error && (r.innerError = t.error), (t.error = r)),
      t.retryCount++;
    let n = 2 ** t.retryCount - 1;
    return (n *=
      0.8 * retryInterval +
      Math.floor(
        Math.random() * (1.2 * retryInterval - 0.8 * retryInterval)
      )),
    (t.retryInterval = Math.min(minRetryInterval + n, maxRetryInterval)),
    t
  ;
  }
  ((nt = N.QueryCollectionFormat || (N.QueryCollectionFormat = {})).Csv = ","),
    (nt.Ssv = " "),
    (nt.Tsv = "\t"),
    (nt.Pipes = "|"),
    (nt.Multi = "Multi");
  const ut = new Error("AgentPolicy is not supported in browser environment");
  let lt;
  S(ct, (lt = re)),
    (ct.prototype.sendRequest = e => {
      throw ut;
    });
  function ct(e, t) {
    lt.call(this, e, t);
    throw ut;
  }
  const ft = new Error("ProxyPolicy is not supported in browser environment");
  function pt(e) {}
  function ht(e) {
    return {
      create(e, t) {
        throw ft;
      },
    };
  }
  let dt;
  S(yt, (dt = re)),
    (yt.prototype.sendRequest = e => {
      throw ft;
    });
  function yt(e, t) {
    dt.call(this, e, t);
    throw ft;
  }
  const mt = c.HttpConstants.StatusCodes;
  function vt() {
    return {
      create(e, t) {
        return new bt(e, t);
      },
    };
  }
  let gt;

  var bt =
    (S(wt, (gt = re)),
    (wt.prototype.sendRequest = function (r) {
      return x(this, void 0, void 0, function () {
        const t = this;
        return C(this, function (e) {
          return [
            2,
            this._nextPolicy.sendRequest(r.clone()).then(e => {
              return e.status !== mt.TooManyRequests
                ? e
                : t._handleResponse(r, e);
            }),
          ];
        });
      });
    }),
    (wt.prototype._defaultResponseHandler = function (o, i) {
      return x(this, void 0, void 0, function () {
        let t;
        let r;
        const n = this;
        return C(this, e => {
          return (t = i.headers.get(c.HeaderConstants.RETRY_AFTER)) &&
            (r = wt.parseRetryAfterHeader(t))
            ? [
                2,
                h(r).then(e => {
                  return n._nextPolicy.sendRequest(o);
                }),
              ]
            : [2, i];
        });
      });
    }),
    (wt.parseRetryAfterHeader = e => {
      const t = Number(e);
      return Number.isNaN(t) ? wt.parseDateRetryAfterHeader(e) : 1e3 * t;
    }),
    (wt.parseDateRetryAfterHeader = e => {
      try {
        const t = Date.now();
        const r = Date.parse(e) - t;
        return Number.isNaN(r) ? void 0 : r;
      } catch (e) {
        return;
      }
    }),
    wt);

  function wt(e, t, r) {
    const n = gt.call(this, e, t) || this;
    return (n._handleResponse = r || n._defaultResponseHandler), n;
  }
  const Et =
    ((Rt.prototype.sendRequest = function (e) {
      if (null == e || "object" != typeof e)
        throw new Error(
          "options cannot be null or undefined and it must be of type object."
        );
      let t;
      try {
        t =
          e instanceof A
            ? (e.validateRequestProperties(), e)
            : (t = new A()).prepare(e);
      } catch (e) {
        return Promise.reject(e);
      }
      let r = this._httpClient;
      if (
        this._requestPolicyFactories &&
        0 < this._requestPolicyFactories.length
      )
        for (let n = this._requestPolicyFactories.length - 1; 0 <= n; --n)
          r = this._requestPolicyFactories[n].create(
            r,
            this._requestPolicyOptions
          );
      return r.sendRequest(t);
    }),
    (Rt.prototype.sendOperationRequest = function (e, t, r) {
    "function" == typeof e.options && ((r = e.options), (e.options = void 0));
    let n;
    const o = new A();
    try {
      const i = t.baseUrl || this.baseUri;
      if (!i)
        throw new Error(
          "If operationSpec.baseUrl is not specified, then the ServiceClient must have a baseUri string property that contains the base URL to use."
        );
      (o.method = t.httpMethod), (o.operationSpec = t);
      const a = Ae.parse(i);
      if (
        (t.path && a.appendPath(t.path),
        t.urlParameters && 0 < t.urlParameters.length)
      )
        for (let s = 0, u = t.urlParameters; s < u.length; s++) {
          const l = u[s];
          let c = _t(this, e, l, t.serializer);
          (c = t.serializer.serialize(l.mapper, c, V(l))),
            l.skipEncoding || (c = encodeURIComponent(c)),
            a.replaceAll(`{${l.mapper.serializedName || V(l)}}`, c);
        }
      if (t.queryParameters && 0 < t.queryParameters.length)
        for (let f = 0, p = t.queryParameters; f < p.length; f++) {
          const h = p[f];
          let d = _t(this, e, h, t.serializer);
          if (null != d) {
            if (
              ((d = t.serializer.serialize(h.mapper, d, V(h))),
              null != h.collectionFormat)
            )
              if (h.collectionFormat === N.QueryCollectionFormat.Multi)
                if (0 === d.length) d = "";
                else
                  for (var y in d) {
                    const m = d[y];
                    d[y] = null == m ? "" : m.toString();
                  }
              else d = d.join(h.collectionFormat);
            if (!h.skipEncoding)
              if (Array.isArray(d))
                for (var y in d) d[y] = encodeURIComponent(d[y]);
              else d = encodeURIComponent(d);
            a.setQueryParameter(h.mapper.serializedName || V(h), d);
          }
        }
      o.url = a.toString();
      const v = t.contentType || this.requestContentType;
      if ((v && o.headers.set("Content-Type", v), t.headerParameters))
        for (let g = 0, b = t.headerParameters; g < b.length; g++) {
          const w = b[g];
          let E = _t(this, e, w, t.serializer);
          if (null != E) {
            E = t.serializer.serialize(w.mapper, E, V(w));
            const R = w.mapper.headerCollectionPrefix;
            if (R)
              for (let T = 0, _ = Object.keys(E); T < _.length; T++) {
                const P = _[T];
                o.headers.set(R + P, E[P]);
              }
            else o.headers.set(w.mapper.serializedName || V(w), E);
          }
        }
      const S = e.options;
      if (S) {
        if (S.customHeaders)
          for (const O in S.customHeaders) o.headers.set(O, S.customHeaders[O]);
        S.abortSignal && (o.abortSignal = S.abortSignal),
          S.timeout && (o.timeout = S.timeout),
          S.onUploadProgress && (o.onUploadProgress = S.onUploadProgress),
          S.onDownloadProgress &&
            (o.onDownloadProgress = S.onDownloadProgress);
      }
      o.withCredentials = this._withCredentials, ((e, t, r, {requestBody, serializer, isXML, formDataParameters}) => {
        if (requestBody && requestBody.mapper) {
          t.body = _t(e, r, requestBody, serializer);
          const o = requestBody.mapper;
          const i = o.required;
          const a = o.xmlName;
          const s = o.xmlElementName;
          const u = o.serializedName;
          const l = o.type.name;
          try {
            if (null != t.body || i) {
              const c = V(requestBody);
              t.body = serializer.serialize(o, t.body, c);
              const f = l === q.Stream;
              isXML
                ? l === q.Sequence
                  ? (t.body = ee(((e, t) => {
                let r;
                return (
                  Array.isArray(e) || (e = [e]),
                  ((r = {})[t] = e),
                  r
                );
              })(t.body, s || a || u), { rootName: a || u }))
                  : f || (t.body = ee(t.body, { rootName: a || u }))
                : f || (t.body = JSON.stringify(t.body));
            }
          } catch (e) {
            throw new Error(
              `Error "${e.message}" occurred in serializing the payload - ${JSON.stringify(u, void 0, "  ")}.`
            );
          }
        } else if (
          formDataParameters &&
          0 < formDataParameters.length
        ) {
          t.formData = {};
          for (let p = 0, h = formDataParameters; p < h.length; p++) {
            const d = h[p];
            const y = _t(e, r, d, serializer);
            if (null != y) {
              const m = d.mapper.serializedName || V(d);
              t.formData[m] = serializer.serialize(d.mapper, y, V(d));
            }
          }
        }
      })(this, o, e, t), null == o.streamResponseBody && (o.streamResponseBody = X(t)), n = this.sendRequest(o).then(e => {
          return St(e, t.responses[e.status]);
        });
    } catch (e) {
      n = Promise.reject(e);
    }
    const x = r;
    return x &&
      n
        .then(({_response}) => {
          return x(
            null,
            _response.parsedBody,
            _response.request,
            _response
          );
        })
        .catch(e => {
          return x(e);
        }),
    n;
  }),
    Rt);
  function Rt(e, t) {
    if (((t = t || {}), e && !e.signRequest))
      throw new Error(
        "credentials argument needs to implement signRequest method"
      );
    let r;
    if (
      ((this._withCredentials = t.withCredentials || !1),
      (this._httpClient = t.httpClient || new L()),
      (this._requestPolicyOptions = new oe(t.httpPipelineLogger)),
      Array.isArray(t.requestPolicyFactories))
    )
      r = t.requestPolicyFactories;
    else if (
      ((r = ((e, t) => {
      const r = [];
      t.generateClientRequestIdHeader &&
        r.push(ge(t.clientRequestIdHeaderName));
      e &&
        (!(({create}) => {
          return "function" == typeof create;
        })(e)
          ? r.push(Ge(e))
          : r.push(e));
      const n = Tt(t.userAgentHeaderName, Te);
      const o = Tt(t.userAgent, _e);
      n && o && r.push(Pe({ key: n, value: o }));
      r.push(Fe()),
        r.push((r => {
          return void 0 === r && (r = 30),
          {
            create(e, t) {
              return new Xe(e, t, r);
            },
          }
        ;
        })(t.rpRegistrationRetryTimeout)),
        t.noRetryPolicy || (r.push(he()), r.push(tt()), r.push(vt()));
      r.push(ae(t.deserializationContentTypes));
      const i = t.proxySettings || void 0;
      i && r.push(ht());
      t.agentSettings &&
        r.push(
          (t.agentSettings,
          {
            create(e, t) {
              throw ut;
            },
          })
        );
      return r;
    })(e, t)),
      t.requestPolicyFactories)
    ) {
      const n = t.requestPolicyFactories(r);
      n && (r = n);
    }
    this._requestPolicyFactories = r;
  }
  function Tt(e, t) {
    let r;
    return (
      "string" == typeof e
        ? (r = e)
        : ((r = t()), "function" == typeof e && (r = e(r))),
      r
    );
  }
  function _t(e, t, {parameterPath, mapper}, n) {
    return (function e(t, r, n, o, i) {
      let a;
      "string" == typeof n && (n = [n]);
      if (Array.isArray(n)) {
        if (0 < n.length) {
          if (o.isConstant) a = o.defaultValue;
          else {
            let s = Pt(r, n);
            s.propertyFound || (s = Pt(t, n));
            let u = !1;
            s.propertyFound ||
              (u = o.required || ("options" === n[0] && 2 === n.length)),
              (a = u ? o.defaultValue : s.propertyValue);
          }
          const l = Y(n, o);
          i.serialize(o, a, l);
        }
      } else
        for (const c in (o.required && (a = {}), n)) {
          const f = o.type.modelProperties[c];
          const p = n[c];
          const h = e(t, r, p, f, i);
          const d = Y(p, f);
          i.serialize(f, h, d), void 0 !== h && ((a = a || {})[c] = h);
        }
      return a;
    })(e, t, parameterPath, mapper, n);
  }
  function Pt(e, t) {
    for (var r = { propertyFound: !1 }, n = 0; n < t.length; ++n) {
      const o = t[n];
      if (!(null != e && o in e)) break;
      e = e[o];
    }
    return n === t.length && ((r.propertyValue = e), (r.propertyFound = !0)), r;
  }
  function St(t, e) {
    function r(e) {
      return Object.defineProperty(e, "_response", { value: t });
    }
    const n = t.parsedHeaders;
    const o = e && e.bodyMapper;
    if (o) {
      const i = o.type.name;
      if ("Stream" === i)
        return r(
          O({}, n, {
            blobBody: t.blobBody,
            readableStreamBody: t.readableStreamBody,
          })
        );
      const a = ("Composite" === i && o.type.modelProperties) || {};

      const s = Object.keys(a).some(e => {
        return "" === a[e].serializedName;
      });

      if ("Sequence" === i || s) {
        for (
          var u = (Array.isArray(t.parsedBody) ? t.parsedBody : []).slice(),
            l = 0,
            c = Object.keys(a);
          l < c.length;
          l++
        ) {
          var f = c[l];
          a[f].serializedName && (u[f] = t.parsedBody[f]);
        }
        if (n)
          for (let p = 0, h = Object.keys(n); p < h.length; p++) {
            u[(f = h[p])] = n[f];
          }
        return r(u), u;
      }
      if ("Composite" === i || "Dictionary" === i)
        return r(O({}, n, t.parsedBody));
    }
    return o || "HEAD" === t.request.method
      ? r(O({}, n, { body: t.parsedBody }))
      : r(O({}, n, t.parsedBody));
  }
  let Ot;

  const xt =
    (S(Nt, (Ot = re)),
    (Nt.prototype.sendRequest = function (e) {
      const t = this;
      return this._nextPolicy.sendRequest(e).then(e => {
        return ((e, t) => {
          e.logger(`>> Request: ${JSON.stringify(t.request, void 0, 2)}`),
            e.logger(`>> Response status code: ${t.status}`);
          const r = t.bodyAsText;
          return e.logger(`>> Body: ${r}`), Promise.resolve(t);
        })(t, e);
      });
    }),
    Nt);

  function Nt(e, t, r) {
    void 0 === r && (r = console.log);
    const n = Ot.call(this, e, t) || this;
    return (n.logger = r), n;
  }
  const qt = c.HeaderConstants;

  const At =
    ((Ct.prototype.signRequest = function (e) {
      return e.headers || (e.headers = new d()),
      e.headers.set(
        qt.AUTHORIZATION,
        `${this.authorizationScheme} ${this.token}`
      ),
      Promise.resolve(e)
    ;
    }),
    Ct);

  function Ct(e, t) {
    if (
      (void 0 === t && (t = "Bearer"),
      (this.authorizationScheme = "Bearer"),
      !e)
    )
      throw new Error("token cannot be null or undefined.");
    (this.token = e), (this.authorizationScheme = t);
  }
  const Dt = c.HeaderConstants;

  const It =
    ((Ut.prototype.signRequest = function (e) {
      const t = `${this.userName}:${this.password}`, r = `${this.authorizationScheme} ${btoa(t)}`;
      return (
        e.headers || (e.headers = new d()),
        e.headers.set(Dt.AUTHORIZATION, r),
        Promise.resolve(e)
      );
    }),
    Ut);

  function Ut(e, t, r) {
    if (
      (void 0 === r && (r = "Basic"),
      (this.authorizationScheme = "Basic"),
      null == e || "string" != typeof e.valueOf())
    )
      throw new Error(
        "userName cannot be null or undefined and must be of type string."
      );
    if (null == t || "string" != typeof t.valueOf())
      throw new Error(
        "password cannot be null or undefined and must be of type string."
      );
    (this.userName = e), (this.password = t), (this.authorizationScheme = r);
  }
  const Ht =
    ((Mt.prototype.signRequest = function (e) {
      if (!e)
        return Promise.reject(
          new Error(
            'webResource cannot be null or undefined and must be of type "object".'
          )
        );
      if (this.inHeader)
        for (const t in (e.headers || (e.headers = new d()), this.inHeader))
          e.headers.set(t, this.inHeader[t]);
      if (this.inQuery) {
        if (!e.url)
          return Promise.reject(
            new Error("url cannot be null in the request object.")
          );
        for (const r in (!e.url.includes("?") && (e.url += "?"), this.inQuery))
          e.url.endsWith("?") || (e.url += "&"),
            (e.url += `${r}=${this.inQuery[r]}`);
      }
      return Promise.resolve(e);
    }),
    Mt);
  function Mt(e) {
    if (!e || (e && !e.inHeader && !e.inQuery))
      throw new Error(
        'options cannot be null or undefined. Either "inHeader" or "inQuery" property of the options object needs to be provided.'
      );
    (this.inHeader = e.inHeader), (this.inQuery = e.inQuery);
  }
  let zt;
  const jt = (S(kt, (zt = Ht)), kt);
  function kt(e) {
    if (!e || (e && "string" != typeof e))
      throw new Error(
        "topicKey cannot be null or undefined and must be of type string."
      );
    const t = { inHeader: { "aeg-sas-key": e } };
    return zt.call(this, t) || this;
  }
  let Lt;
  const Bt = (S(Ft, (Lt = Ht)), Ft);
  function Ft(e) {
    if (!e || (e && "string" != typeof e))
      throw new Error(
        "domainKey cannot be null or undefined and must be of type string."
      );
    const t = { inHeader: { "aeg-sas-key": e } };
    return Lt.call(this, t) || this;
  }
  (N.WebResource = A),
    (N.DefaultHttpClient = L),
    (N.HttpHeaders = d),
    (N.RestError = z),
    (N.ServiceClient = Et),
    (N.flattenResponse = St),
    (N.Constants = c),
    (N.logPolicy = r => {
      return void 0 === r && (r = console.log),
      {
        create(e, t) {
          return new xt(e, t, r);
        },
      }
    ;
    }),
    (N.BaseRequestPolicy = re),
    (N.RequestPolicyOptions = oe),
    (N.generateClientRequestIdPolicy = ge),
    (N.exponentialRetryPolicy = he),
    (N.systemErrorRetryPolicy = tt),
    (N.throttlingRetryPolicy = vt),
    (N.getDefaultProxySettings = pt),
    (N.proxyPolicy = ht),
    (N.redirectPolicy = Fe),
    (N.signingPolicy = Ge),
    (N.userAgentPolicy = Pe),
    (N.getDefaultUserAgentValue = _e),
    (N.deserializationPolicy = ae),
    (N.deserializeResponseBody = pe),
    (N.MapperType = q),
    (N.Serializer = E),
    (N.serializeObject = function e(t) {
      if (null != t) {
        if (t instanceof Uint8Array) return (t = s(t));
        if (t instanceof Date) return t.toISOString();
        if (Array.isArray(t)) {
          for (var r = [], n = 0; n < t.length; n++) r.push(e(t[n]));
          return r;
        }
        if ("object" != typeof t) return t;
        const o = {};
        for (const i in t) o[i] = e(t[i]);
        return o;
      }
    }),
    (N.stripRequest = g),
    (N.stripResponse = v),
    (N.delay = h),
    (N.executePromisesSequentially = (e, t) => {
      let r = Promise.resolve(t);
      return e.forEach(e => {
        r = r.then(e);
      }),
      r
    ;
    }),
    (N.generateUuid = y),
    (N.encodeUri = e => {
      return encodeURIComponent(e)
        .replace(/!/g, "%21")
        .replace(/"/g, "%27")
        .replace(/\(/g, "%28")
        .replace(/\)/g, "%29")
        .replace(/\*/g, "%2A");
    }),
    (N.promiseToCallback = e => {
      if ("function" != typeof e.then)
        throw new Error("The provided input is not a Promise.");
      return t => {
        e.then(
          e => {
            t(void 0, e);
          },
          e => {
            t(e);
          }
        );
      };
    }),
    (N.promiseToServiceCallback = e => {
      if ("function" != typeof e.then)
        throw new Error("The provided input is not a Promise.");
      return t => {
        e.then(
          e => {
            process.nextTick(t, void 0, e.parsedBody, e.request, e);
          },
          e => {
            process.nextTick(t, e);
          }
        );
      };
    }),
    (N.isValidUuid = p),
    (N.applyMixins = ({prototype}, e) => {
      e.forEach(({prototype}) => {
        Object.getOwnPropertyNames(prototype).forEach(e => {
          prototype[e] = prototype[e];
        });
      });
    }),
    (N.isNode = f),
    (N.isDuration = b),
    (N.URLBuilder = Ae),
    (N.URLQuery = Ne),
    (N.TokenCredentials = At),
    (N.BasicAuthenticationCredentials = It),
    (N.ApiKeyCredentials = Ht),
    (N.TopicCredentials = jt),
    (N.DomainCredentials = Bt),
    Object.defineProperty(N, "__esModule", { value: !0 });
});
